<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="codeva-kligclmjAj" />
  
  
  <title>c7w&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="description" content="c7w 的博客">
  
  
  
    <link rel="shortcut icon" href="../favicon.ico">
  
  <link rel="stylesheet" href="../css/style.css">
  
    <link rel="stylesheet" href="../fancybox/jquery.fancybox-1.3.4.css">
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <div id="nav-outer">
  <nav id="main-nav" class="outer">
    <a id="main-nav-toggle" class="nav-icon"></a>
    
      <a class="main-nav-link" href="../index.html">Home</a>
    
      <a class="main-nav-link" href="../archives">Posts</a>
    
      <a class="main-nav-link" href="../about">About</a>
    
      <a class="main-nav-link" href="../friends">Friends</a>
    
    <div class="main-nav-space-between"></div>
    
  </nav>
</div>
<!-- <div id="header-title">
  <h1 id="logo-wrap">
    <a href="../index.html" id="logo">c7w&#39;s Blog</a>
  </h1>
  
    <h2 id="subtitle-wrap">
      <a href="../index.html" id="subtitle">Ready for some fun stuff :)</a>
    </h2>
  
</div> -->

      <div id="content" class="outer">
        <section id="main">
  
    <article id="post-test-time-scaling" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a class="article-date">
  <time class="dt-published" datetime="2024-11-19T15:36:09.146Z" itemprop="datePublished">2024-11-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../categories/LLM/">LLM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="../posts/test-time-scaling/">随笔：Test-time Computation Scaling</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>主要是针对 <strong>Scaling LLM Test-Time Compute Optimally can be More Effective than Scaling Model Parameters</strong> (Google DeepMind) 这篇 Paper 的一些结论总结<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="abstract">Abstract</h2>
<p>Enabling LLMs to improve their outputs by using more test-time computation is a critical step towards building generally self-improving agents that can operate on open-ended natural language. In this paper, we study the scaling of inference-time computation in LLMs, with a focus on answering the question: <strong>if an LLM is allowed to use a fixed but non-trivial amount of inference-time compute, how much can it improve its performance on a challenging prompt?</strong> Answering this question has implications not only on the achievable performance of LLMs, but also on the future of LLM pretraining and how one should tradeoff inference-time and pre-training compute. Despite its importance, little research attempted to understand the scaling behaviors of various test-time inference methods. Moreover, current work largely provides negative results for a number of these strategies. <strong>In this work, we analyze two primary mechanisms to scale test-time computation: (1) searching against dense, process-based verifier reward models; and (2) updating the model’s distribution over a response adaptively, given the prompt at test time.</strong> We find that in both cases, the effectiveness of different approaches to <strong>scaling test-time compute critically varies depending on the difficulty of the prompt</strong>. <strong>This observation motivates applying a <span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>compute-optimal<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span> scaling strategy, which acts to most effectively allocate test-time compute adaptively per prompt</strong>. Using this compute-optimal strategy, we can improve the efficiency of test-time compute scaling by more than 4× compared to a best-of-N baseline. Additionally, in a FLOPs-matched evaluation, we find that on problems where a smaller base model attains somewhat non-trivial success rates, test-time compute can be used to outperform a 14× larger model.</p>
<p>问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>Test-time scaling<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>背景<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>评估了两种test-time scaling的方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>Motivation<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>两种方法的成功与否都与当前prompt对应任务的难度有关<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>dynamic allocation of computation resource to each task.</p>
<h2 id="a-unified perspective on test-time computation: proposer and verifier">A Unified Perspective on Test-Time Computation: Proposer and Verifier</h2>
<p>介绍了被评估的两种 test-time scaling的方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也是值得我们思考是否可以被用在其他领域的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这里的 Proposer 在 LLM 的 setting 下可以认为是大语言模型自身<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>Verifier 可以被认为是一个外部的预训练好的或者是预定义好的 reward model<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>Modifying the proposal distribution.</strong> One way to improve the proposal distribution is to directly optimize the model for a given reasoning task via RL-inspired finetuning methods such as STaR or ReSTEM. Note that these techniques do not utilize any additional input tokens but specifically finetune the model to induce an improved proposal distribution. Instead, techniques such as self-critique enable the model itself to improve its own proposal distribution at test time by instructing it to critique and revise its own outputs in an iterative fashion. Since prompting off-the-shelf models is not effective at enabling effective revisions at test time, we specifically finetune models to iteratively revise their answers in complex reasoning-based settings. To do so, we utilize the approach of finetuning on on-policy data with Best-of-N guided improvements to the model response.</p>
<p>[1] Recursive Introspection: Teaching Language Model Agents How to Self-Improve. (CMU, UCB)</p>
<p><img src="test-time-scaling.assets/image.png" alt="image.png"></p>
<p><img src="test-time-scaling.assets/image%201.png" alt="image.png"></p>
<p>这类方法在 test-time scaling 的时候可以将 inference budget 分配给 图 1 的 Inference Turn 这里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>图 2 是其训练数据的构造过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p>
<p><strong>Optimizing the verifier.</strong> In our abstraction of the proposal distribution and verifier, the verifier is used to aggregate or select the best answer from the proposal distribution. The most canonical way to use such a verifier is by applying best-of-N sampling, wherein we sample N complete solutions and then select the best one according to a verifier. However, this approach can be further improved by training a process-based verifier, or a process reward model (PRM), which produces a prediction of the correctness of each intermediate step in a solution, rather than just the final answer. We can then utilize these per-step predictions to perform tree search over the space of solutions, enabling a potentially more efficient and effective way to search against a verifier, compared to naïve best-of-N.</p>
<p>[1] Training Verifiers to Solve Math Word Problems. (OpenAI. To increase performance, we propose training verifiers to judge the correctness of model completions. At test time, we generate many candidate solutions and select the one ranked highest by the verifier.)</p>
<p>[2] Let’s Verify Step by Step. (OpenAI. Introducing process supervision, which provides feedback for each intermediate reasoning step.)</p>
<p><img src="test-time-scaling.assets/image%202.png" alt="image.png"></p>
<p><img src="test-time-scaling.assets/image%203.png" alt="image.png"></p>
<h2 id="scaling-test-time computation optimally">Scaling Test-Time Computation Optimally</h2>
<p>本文自己提出的方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>It tackles this problem: when using a model finetuned for revisions as the proposal distribution and an ORM (Outcome Reward Model, or Sparse Reward Model) as the verifier, we could either spend the full test-time compute budget on generating N independent samples in parallel from the model and then apply best-of-N, or we could sample N revisions in sequence using a revision model and then select the best answer in the sequence with an ORM, or strike a balance between these extremes. 也就是说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>探究在这两种方法下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在有限的 inference budget 的前提下达到更好的能力<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>Intuitively, we might expect <span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>easier<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span> problems to benefit more from revisions, since the model’s initial samples are more likely to be on the right track but may just need further refinement. On the other hand, challenging problems may require more exploration of different high-level problem solving strategies, so sampling many times independently in parallel may be preferable in this setting.</p>
<p>于是我们去 Estimate Question 的 Difficulty. We bin the model’s pass@1 rate—estimated from 2048 samples—on each question in the test set into five quantiles, each corresponding to increasing difficulty levels, and use the final answer score from a learned verifier (and not groundtruth answer correctness checks).</p>
<h2 id="实验">实验</h2>
<p><img src="test-time-scaling.assets/image%204.png" alt="image.png"></p>
<p><img src="test-time-scaling.assets/image%205.png" alt="image.png"></p>
<p><img src="test-time-scaling.assets/image%206.png" alt="image.png"></p>
<h2 id="其他想法的讨论">其他想法的讨论</h2>
<ul>
<li>Diffusion 生成的 Test-time Scaling 时刻<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>Well…Diffusion 的单次推理开销已经在一定程度上限制了在 test-time 推理的可行性<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>Though 很多设计师确实会生成多次然后用 best-of-N<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>把自己当成一个 verifier<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>同时 Sanja Fidler 挂名的 ICML 24 的 Paper <em>Align your steps</em> 其实做了 scheduler space 的 timestep 的搜索<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>somehow 和改变生成式模型的输出分布这件事很像<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
<li>在具身的应用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>Actually 这个paper里的一些概念从 RL 里 borrow 来的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一方面是 few-shot demonstration 确实已经被证明了在训练阶段有用<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>虽然 in-context learning from inference stage remains to be explored, 这个还是先等 scalable 的 robotics transformer 开发出来再说吧<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>另一方面是 real-world 不是一个可以 reset 的仿真环境<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不太能像 LLM 的 decoding 一样搜索与回溯<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ul>

      
    </div>
    <footer class="article-footer">
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-diffusion-dpo" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a class="article-date">
  <time class="dt-published" datetime="2024-08-27T13:45:18.426Z" itemprop="datePublished">2024-08-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../categories/Diffusion/">Diffusion</a>►<a class="article-category-link" href="../categories/Diffusion/Post-training/">Post-training</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="../posts/diffusion-dpo/">Diffusion-DPO 公式推导</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数学推导">数学推导</h1>
<p>在这篇笔记中我们给出 Diffusion DPO 的推导<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>推导过程参考了 [1] 的内容<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="diffusion-dpo loss objective">Diffusion DPO Loss Objective</h2>
<p>我们先给出我们终极的推导目标<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$L(\theta) = -\mathbb{E}_{(x_0^w, x_0^l) \sim \mathcal{D}, t \sim \mathcal{U}(0, T), x_t^w \sim q(x_t^w|x_0^w), x_t^l \sim q(x_t^l|x_0^l)} \\
\log \sigma \left( -\beta T \omega(\lambda_t) \left( 
\| \epsilon^w - \epsilon_\theta(x_t^w, t) \|_2^2 - \| \epsilon^w - \epsilon_{\text{ref}}(x_t^w, t) \|_2^2 
- \left( \| \epsilon^l - \epsilon_\theta(x_t^l, t) \|_2^2 - \| \epsilon^l - \epsilon_{\text{ref}}(x_t^l, t) \|_2^2 \right) 
\right) \right)
$$</div><h2 id="from-rlhf to dpo">From RLHF to DPO</h2>
<p>我们先介绍 Bradley-Terry 模型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它将人类偏好 <span class="markdown-them-math-inline">$x_0^w$</span> over <span class="markdown-them-math-inline">$x_0^l$</span> 这件事用一个 Sigmoid 函数来建模<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$\begin{equation}p_{\text{BT}}(x_0^w \succ x_0^l \mid c) = \sigma \left( r(c, x_0^w) - r(c, x_0^l) \right)\end{equation}
$$</div><p>这里 r 是一个 reward model<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用来衡量 <span class="markdown-them-math-inline">$x_0^*$</span> 与 <span class="markdown-them-math-inline">$c$</span> 和人类偏好的符合程度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>一个很自然的 idea 就是把 r 用另一个 pretrained 知识源来替代<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>比如随便搜了一下发现有很多 CLIP-DPO<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果没有这个外部的 r 函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也可以用 data-driven 的方式学一个 r 函数出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$\begin{equation}L_{\text{BT}}(\phi) = -\mathbb{E}_{c, x_0^w, x_0^l} \left[ \log \sigma \left( r_{\phi}(c, x_0^w) - r_{\phi}(c, x_0^l) \right) \right]\end{equation}
$$</div><p>有了 r 函数之后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们定义 RLHF 是一个对生成式模型 <span class="markdown-them-math-inline">$p_\theta(\mathbf{x}_0|\mathbf{c})$</span> 训练过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个过程可以使得我们通过上述方式定义的 reward function <span class="markdown-them-math-inline">$r(\mathbf{c}, \mathbf{x}_0)$</span> 在微调后的生成分布上取得较大的值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时通过 KL-Divergence 约束微调导致的分布偏移量并不大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$\max_{p_\theta} \mathbb{E}_{\mathbf{c} \sim \mathcal{D}_c, \mathbf{x}_0 \sim p_\theta(\mathbf{x}_0|\mathbf{c})} \left[r(\mathbf{c}, \mathbf{x}_0)\right]    - \beta \, \text{KL}\left[p_\theta(\mathbf{x}_0|\mathbf{c}) \| p_{\text{ref}}(\mathbf{x}_0|\mathbf{c})\right]
$$</div><p>这个 RLHF 的极点事实上是有闭式解的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以将其表示为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$\begin{aligned}\operatorname*{max}_{\pi}\mathbb{E}_{x\sim\mathcal{D},y\sim\pi}&amp; \left[r(x,y)\right]-\beta\mathbb{D}_{\mathrm{KL}}\left[\pi(y|x)\parallel\pi_{\mathrm{ref}}(y|x)\right] \\&amp;=\max_\pi\mathbb{E}_{x\sim\mathcal{D}}\mathbb{E}_{y\sim\pi(y|x)}\left[r(x,y)-\beta\log\frac{\pi(y|x)}{\pi_{\mathrm{ref}}(y|x)}\right] \\&amp;=\min_{\pi}\mathbb{E}_{x\sim\mathcal{D}}\mathbb{E}_{y\sim\pi(y|x)}\left[\log\frac{\pi(y|x)}{\pi_{\mathrm{ref}}(y|x)}-\frac{1}{\beta}r(x,y)\right] \\&amp;=\min_{\pi}\mathbb{E}_{x\sim\mathcal{D}}\mathbb{E}_{y\sim\pi(y|x)}\left[\log\frac{\pi(y|x)}{\frac{1}{Z(x)}\pi_{\mathrm{ref}}(y|x)\exp\left(\frac{1}{\beta}r(x,y)\right)}-\log Z(x)\right]\end{aligned}
$$</div><p>这里 KL Divergence 在对 y 取期望的意义下展开<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>Z(x) 是归一化函数<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>原文将其称为 partition function<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$Z(x)=\sum_y\pi_\text{ref}(y|x)\exp\left(\frac{1}{\beta}r(x,y)\right)
$$</div><p>由于 <span class="markdown-them-math-inline">$\log Z(x)$</span> 项与 <span class="markdown-them-math-inline">$\pi$</span> 无关<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>让这个熵最小等价于分子和分母两个分布完全相同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$\pi^*(y|x)=\frac{1}{Z(x)}\pi_{\text{ref}}(y|x)\exp\left(\frac{1}{\beta}r(x,y)\right)
$$</div><p>换元回生成式模型的表示<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$p_\theta^*(\boldsymbol{x}_0|\boldsymbol{c})=p_{\mathrm{ref}}(\boldsymbol{x}_0|\boldsymbol{c})\exp\left(r(\boldsymbol{c},\boldsymbol{x}_0)/\beta\right)/Z(\boldsymbol{c})
$$</div><p>因此<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以移项表示 reward function<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$r(\boldsymbol{c},\boldsymbol{x}_0)=\beta\log\frac{p_\theta^*(\boldsymbol{x}_0|\boldsymbol{c})}{p_\text{ref}(\boldsymbol{x}_0|\boldsymbol{c})}+\beta\log Z(\boldsymbol{c})
$$</div><p>代入 <span class="markdown-them-math-inline">$L_{\text{BT}}(\phi)$</span> 中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们发现模型参数 <span class="markdown-them-math-inline">$\theta$</span> 本身变成了一个 reward model<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$L_{\mathrm{DPO}}(\theta)=-\mathbb{E}_{\boldsymbol{c},\boldsymbol{x}_{0}^{w},\boldsymbol{x}_{0}^{l}}\left[\log\sigma\left(\beta\log\frac{p_{\theta}(\boldsymbol{x}_{0}^{w}|\boldsymbol{c})}{p_{\mathrm{ref}}(\boldsymbol{x}_{0}^{w}|\boldsymbol{c})}-\beta\log\frac{p_{\theta}(\boldsymbol{x}_{0}^{l}|\boldsymbol{c})}{p_{\mathrm{ref}}(\boldsymbol{x}_{0}^{l}|\boldsymbol{c})}\right)\right]
$$</div><h2 id="dpo-on diffusion">DPO on Diffusion</h2>
<p>在这个阶段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最大的挑战是 <span class="markdown-them-math-inline">$p_\theta(\boldsymbol{x}_0|\boldsymbol{c})$</span> 可以由 <span class="markdown-them-math-inline">$p(\boldsymbol{x}_T)$</span> 由多条 Diffusion Path 生成出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是我们重新利用 Diffusion 利用 ELBO 的想法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们将奖励函数定义在 <span class="markdown-them-math-inline">$\boldsymbol{x}_{0:T}$</span> 上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$r(\boldsymbol{c},\boldsymbol{x}_0)=\mathbb{E}_{p_\theta(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0,\boldsymbol{c})}\left[R(\boldsymbol{c},\boldsymbol{x}_{0:T})\right].
$$</div><p>这样定义下的 RLHF 过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>应该满足<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$\max_{p_{\theta}}\mathbb{E}_{\boldsymbol{c}\sim\mathcal{D}_{c},\boldsymbol{x}_{0:T}\sim p_{\theta}(\boldsymbol{x}_{0:T}|\boldsymbol{c})}\left[r(\boldsymbol{c},\boldsymbol{x}_{0})\right]-\beta\mathbb{D}_{\mathrm{KL}}\left[p_{\theta}(\boldsymbol{x}_{0:T}|\boldsymbol{c})\|p_{\mathrm{ref}}(\boldsymbol{x}_{0:T}|\boldsymbol{c})\right]
$$</div><p>我们也可以为这个过程推导出 DPO 的 Loss 函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$L_{\mathrm{DPO-Diffusion}}(\theta)=-\mathbb{E}_{(\boldsymbol{x}_{0}^{w},\boldsymbol{x}_{0}^{t})\sim\mathcal{D}}\log\sigma\bigg(\beta\mathbb{E}_{\boldsymbol{x}_{1:T}^{w}\sim p_{\theta}(\boldsymbol{x}_{1:T}^{w}|\boldsymbol{x}_{0}^{w})}\left[\log\frac{p_{\theta}(\boldsymbol{x}_{0:T}^{w})}{p_{\mathrm{ref}}(\boldsymbol{x}_{0:T}^{w})}-\log\frac{p_{\theta}(\boldsymbol{x}_{0:T}^{l})}{p_{\mathrm{ref}}(\boldsymbol{x}_{0:T}^{l})}\right]\bigg)
$$</div><p>接下来我们做两个优化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>第一个是解决这需要优化多个时间步的问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>通过和 Diffusion 推导过程类似的 ELBO 推导<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们得到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$L_{\mathrm{DPO-Diffusion}}(\theta)\leq-\mathbb{E}_{(\boldsymbol{x}_{0}^{w},\boldsymbol{x}_{0}^{l})\sim\mathcal{D},t\sim\mathcal{U}(0,T),\boldsymbol{x}_{t-1,t}^{w}\sim p_{\theta}(\boldsymbol{x}_{t-1,t}^{w}|\boldsymbol{x}_{0}^{w}),\boldsymbol{x}_{t-1,t}^{l}\sim p_{\theta}(\boldsymbol{x}_{t-1,t}^{l}|\boldsymbol{x}_{0}^{l})}\\\log\sigma\left(\beta T\log\frac{p_{\theta}(\boldsymbol{x}_{t-1}^{w}|\boldsymbol{x}_{t}^{w})}{p_{\mathrm{ref}}(\boldsymbol{x}_{t-1}^{w}|\boldsymbol{x}_{t}^{w})}-\beta T\log\frac{p_{\theta}(\boldsymbol{x}_{t-1}^{l}|\boldsymbol{x}_{t}^{l})}{p_{\mathrm{ref}}(\boldsymbol{x}_{t-1}^{l}|\boldsymbol{x}_{t}^{l})}\right)
$$</div><p>然后是 <span class="markdown-them-math-inline">$p_\theta(x_{t-1},x_t|x_0,c)$</span> 不可解的问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们使用 <span class="markdown-them-math-inline">$q$</span> 过程来对这个取变量算期望的过程做估计<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$\begin{aligned}L(\theta)=-&amp; \mathbb{E}_{(\boldsymbol{x}_{0}^{w},\boldsymbol{x}_{0}^{l})\sim\mathcal{D},t\sim\mathcal{U}(0,T),\boldsymbol{x}_{t}^{w}\sim q(\boldsymbol{x}_{t}^{w}|\boldsymbol{x}_{0}^{w}),\boldsymbol{x}_{t}^{l}\sim q(\boldsymbol{x}_{t}^{l}|\boldsymbol{x}_{0}^{l})} \\&amp;\log\sigma(-\beta T( \\&amp;+\mathbb{D}_{\mathrm{KL}}(q(\boldsymbol{x}_{t-1}^w|\boldsymbol{x}_{0,t}^w)\|p_\theta(\boldsymbol{x}_{t-1}^w|\boldsymbol{x}_t^w)) \\&amp;-\mathbb{D}_{\mathrm{KL}}(q(\boldsymbol{x}_{t-1}^w|\boldsymbol{x}_{0,t}^w)\|p_{\mathrm{ref}}(\boldsymbol{x}_{t-1}^w|\boldsymbol{x}_t^w)) \\&amp;-\mathbb{D}_{\mathrm{KL}}(q(\boldsymbol{x}_{t-1}^l|\boldsymbol{x}_{0,t}^l)\|p_\theta(\boldsymbol{x}_{t-1}^l|\boldsymbol{x}_t^l)) \\&amp;+\mathbb{D}_{\mathrm{KL}}(q(\boldsymbol{x}_{t-1}^l|\boldsymbol{x}_{0 t}^l)\|p_{\mathrm{ref}}(\boldsymbol{x}_{t-1}^l|\boldsymbol{x}_{t}^l))).\end{aligned}
$$</div><p>根据 Diffusion Loss 的推导<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这可以被写成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$L(\theta) =-\mathbb{E}_{(\boldsymbol{x}_{0}^{w},\boldsymbol{x}_{0}^{l})\sim\mathcal{D},t\sim\mathcal{U}(0,T),\boldsymbol{x}_{t}^{w}\sim q(\boldsymbol{x}_{t}^{w}|\boldsymbol{x}_{0}^{w}),\boldsymbol{x}_{t}^{l}\sim q(\boldsymbol{x}_{t}^{l}|\boldsymbol{x}_{0}^{l})} \\\log\sigma\left(-\beta T\omega(\lambda_{t})\right)( \|\epsilon^w-\epsilon_\theta(\boldsymbol{x}_t^w,t)\|_2^2-\|\epsilon^w-\epsilon_{\mathrm{ref}}(\boldsymbol{x}_t^w,t)\|_2^2 -\left(\|\boldsymbol{\epsilon}^{l}-\boldsymbol{\epsilon}_{\theta}(\boldsymbol{x}_{t}^{l},t)\|_{2}^{2}-\|\boldsymbol{\epsilon}^{l}-\boldsymbol{\epsilon}_{\mathrm{ref}}(\boldsymbol{x}_{t}^{l},t)\|_{2}^{2}\right)\Big)\Big)
$$</div><h2 id="reference">Reference</h2>
<p>[1] Wallace B, Dang M, Rafailov R, et al. Diffusion model alignment using direct preference optimization[C]//Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition. 2024: 8228-8238.</p>
<p>[2] Rafailov R, Sharma A, Mitchell E, et al. Direct preference optimization: Your language model is secretly a reward model[J]. Advances in Neural Information Processing Systems, 2024, 36.</p>

      
    </div>
    <footer class="article-footer">
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-cs285" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a class="article-date">
  <time class="dt-published" datetime="2023-10-07T21:32:06.960Z" itemprop="datePublished">2023-10-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../categories/RL/">RL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="../posts/cs285/">Note for CS 285, Deep Reinforcement Learning</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>This is note for CS 285, DRL @ UCB.</p>
<p>Following <a target="_blank" rel="noopener" href="http://rail.eecs.berkeley.edu/deeprlcourse-fa21/">http://rail.eecs.berkeley.edu/deeprlcourse-fa21/</a>.</p>
<h2 id="lec-2 supervised learning of behaviors">Lec 2. Supervised Learning of Behaviors</h2>
<p>首先引入一些记号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>输入的 Observation 记为 <span class="markdown-them-math-inline">$\mathbf o$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>输入图像<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>输出的 Action 记为 <span class="markdown-them-math-inline">$\mathbf a$</span><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>预测标签<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而策略网络<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>Policy<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>记为 <span class="markdown-them-math-inline">$\pi_\theta(\mathbf a \mid \mathbf o)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们使用下标 <span class="markdown-them-math-inline">$t$</span> 来表示离散化之后的时间步<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即 <span class="markdown-them-math-inline">$\mathbf o_t$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\mathbf a_t$</span> 和 <span class="markdown-them-math-inline">$\pi_\theta(\mathbf a_t \mid \mathbf o_t)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>有时我们使用 <span class="markdown-them-math-inline">$\mathbf s_t$</span> 来表示当前时间步的状态<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>State<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\mathbf s_t$</span> 和 <span class="markdown-them-math-inline">$\mathbf o_t$</span> 的区别在于<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>(1) Observation 是观察到的现象<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>State 是由 Action 决定的反应系统状态的量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>(2) 仅使用 Observation 可能没办法去推断 State<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不同的 Observation 可能对应同一个 State<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>(3) 状态 State 往往是被认为满足马尔科夫性质的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而 Observation 却不是如此<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>也有的记号用 <span class="markdown-them-math-inline">$\mathbf x_t$</span> 表示 State<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$\mathbf u_t$</span> 表示 Action<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="cs285.assets/image-20230910152826762.png" alt="image-20230910152826762"></p>
<p><strong>Imitation Learning</strong> 是一种学习 Policy 的方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>它也叫 <strong>behavioral cloning</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即收集了大笔 <span class="markdown-them-math-inline">$\mathbf o_t$</span> 和专家给出的 <span class="markdown-them-math-inline">$\mathbf a_t$</span> 对作为训练数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使用有监督学习的方式去进行学习<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>跟常见的有监督学习不同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这种方式通常来说是不工作的<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>除非训练数据照顾到足够多的 Corner Cases<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这是因为 State 的误差会随着多次 Inference 的时间步累积<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如下图所示<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><img src="cs285.assets/image-20230909231207503.png" alt="image-20230909231207503"></p>
<p><strong><span class="bd-box"><h-char class="bd bd-end"><h-inner>【</h-inner></h-char></span>解决方案 1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>DAgger<span class="bd-box"><h-char class="bd bd-beg"><h-inner>】</h-inner></h-char></span></strong> 想要解决上述的问题<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>Distributional drift Problem<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>解决思路 1 应该是尽可能减少因为误差累积导致的 State 偏差<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>一个可能的解决方案是从训练数据的角度出发<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们尽可能照顾到更多的情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如下图所示<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><img src="cs285.assets/image-20230909231654997.png" alt="image-20230909231654997"></p>
<p>也就是说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们尝试去修改我们的训练数据 <span class="markdown-them-math-inline">$p_\text{data} (\mathbf o_t)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们可以试着以 <span class="markdown-them-math-inline">$p_{\pi_\theta} (\mathbf o_t)$</span> 作为训练状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后让人工标注在这个训练状态下需要什么样的 Action <span class="markdown-them-math-inline">$\mathbf a_t$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后使用当前的策略网络去进行推理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>收集下一个需要标注的状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这种方法叫做 DAgger<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>Dataset Aggregation<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><img src="cs285.assets/image-20230909232153665.png" alt="image-20230909232153665"></p>
<p><strong><span class="bd-box"><h-char class="bd bd-end"><h-inner>【</h-inner></h-char></span>解决方案 2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>更好地拟合专家<span class="bd-box"><h-char class="bd bd-beg"><h-inner>】</h-inner></h-char></span></strong> 另一种解决方案是更好地去拟合专家给出的 Action 数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>减少单步产生的误差<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这主要从以下两个方面着手<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li>Observation 不满足马尔科夫性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>将 Policy 的 Formulation 从 <span class="markdown-them-math-inline">$\pi_\theta(\mathbf a_t \mid \mathbf o_t)$</span> 改为 <span class="markdown-them-math-inline">$\pi_\theta(\mathbf a_t \mid \mathbf o_t, \mathbf o_{t-1}, \cdots, \mathbf o_1)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这通过采用一些具有记忆功能的网络结构来实现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>
<ul>
<li>这样做会一定程度上减轻 Causal Confusion 的问题<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>fixed-capacity policies that are trained to fixed training error on the same demonstrations with access to more information can actually yield worse performance<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
</ul>
</li>
<li>从人类中学到的 Action 并不是唯一的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>(1) 可以考虑输出 mixture of Gaussians 作为答案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>(2) 可以考虑让策略网络输入 latent variable 作为输入<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将 observation 作为 condition 对 random latent variable 进行 decode<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>(3) 自回归离散化 Autoregressive discretization<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>逐个输出维度进行离散化后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对 softmax 之后的结果采样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将采样得到的结果输入另一个网络中进行下一个输出维度的离散化和采样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如此迭代<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ul>
<p><strong><span class="bd-box"><h-char class="bd bd-end"><h-inner>【</h-inner></h-char></span>解决方案 3<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>更稳定的 trajectory<span class="bd-box"><h-char class="bd bd-beg"><h-inner>】</h-inner></h-char></span></strong> 我们也可以让 trajectory 的性质更稳定<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>对微小误差有容忍度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>来解决 Distributional drift 的问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>具体方案在后面的章节介绍<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>小结<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>Imitation Learning 这种范式的固有问题就是需要人类专家来提供数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而这往往是有限或者在表示方式上十分困难的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>Cost functions<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>Reward functions</strong> 的相关介绍<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>从一个具体例子出发<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以形式化表示我们的目标为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$\min _\theta E_{\mathbf{a} \sim \pi_\theta(\mathbf{a} \mid \mathbf{s}), \mathbf{s}^{\prime} \sim p\left(\mathbf{s}^{\prime} \mid \mathbf{s}, \mathbf{a}\right)}\left[\delta\left(\mathbf{s}^{\prime}=\text { eaten by tiger }\right)\right] \\
\Rightarrow \min _\theta E_{\mathbf{s}_{1: T}, \mathbf{a}_{1: T}}\left[\sum_t \delta\left(\mathbf{s}_t=\text { eaten by tiger }\right)\right] \\
\Rightarrow  \min _\theta E_{\mathbf{s}_{1: T}, \mathbf{a}_{1: T}}\left[\sum_t c\left(\mathbf{s}_t, \mathbf{a}_t\right)\right] (*)
$$</div><p>这里 <span class="markdown-them-math-inline">$c(\mathbf s_t, \mathbf a_t)$</span> 就是 cost function<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>或者我们将 min 改成 max 就是 reward function <span class="markdown-them-math-inline">$r$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>Goal-conditioned Policies.</strong> 我们将最终的 Goal State 也作为 Policy Network 的输入<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>通过仿真环境采集足够多的数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并筛选到达某个最终 Goal 的数据出来进行 Retrai</p>
<p><img src="cs285.assets/image-20230910002855958.png" alt="image-20230910002855958"></p>
<h2 id="lec-4 introduction to reinforcement learning">Lec 4. Introduction to Reinforcement Learning</h2>
<h3 id="notations">Notations</h3>
<p><strong>Markov Decision Process</strong> (MDP)</p>
<p><img src="cs285.assets/image-20230910153641900.png" alt="image-20230910153641900"></p>
<p><span class="markdown-them-math-inline">$r$</span> : <span class="markdown-them-math-inline">$\mathcal S \times \mathcal A \rightarrow \mathbb R$</span>, 是 reward function.</p>
<p><strong>Partially-observed MDP</strong></p>
<p><img src="cs285.assets/image-20230910153835737.png" alt="image-20230910153835737"></p>
<p><strong><span class="bd-box"><h-char class="bd bd-end"><h-inner>【</h-inner></h-char></span>强化学习的 Objective<span class="bd-box"><h-char class="bd bd-beg"><h-inner>】</h-inner></h-char></span></strong> 由于 Markov 性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以将强化学习的目标写成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$\begin{gathered}
\underbrace{p_\theta\left(\mathbf{s}_1, \mathbf{a}_1, \ldots, \mathbf{s}_T, \mathbf{a}_T\right)}_{p_\theta(\tau)}=p\left(\mathbf{s}_1\right) \prod_{t=1}^T \pi_\theta\left(\mathbf{a}_t \mid \mathbf{s}_t\right) p\left(\mathbf{s}_{t+1} \mid \mathbf{s}_t, \mathbf{a}_t\right) \\
\\
\theta^{\star} =\arg \max _\theta E_{\tau \sim p_\theta(\tau)}\left[\sum_t r\left(\mathbf{s}_t, \mathbf{a}_t\right)\right] \\
=\arg \max _\theta \sum_{t=1}^T E_{\left(\mathbf{s}_t, \mathbf{a}_t\right) \sim p_\theta\left(\mathbf{s}_t, \mathbf{a}_t\right)}\left[r\left(\mathbf{s}_t, \mathbf{a}_t\right)\right]

\end{gathered}
$$</div><p>这里 <span class="markdown-them-math-inline">$\tau$</span> 表示整个 trajectory<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$p_\theta\left(\mathbf{s}_t, \mathbf{a}_t\right)$</span> 是 state-action marginal distribution<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>当我们考虑无穷步的时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于 <span class="markdown-them-math-inline">$p_\theta\left(\mathbf{s}_t, \mathbf{a}_t\right)$</span> 最终会收敛成静态分布 <span class="markdown-them-math-inline">$p_\theta\left(\mathbf{s}, \mathbf{a}\right)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以将强化学习的目标写成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$\theta^{\star}=\arg \max _\theta \frac{1}{T} \sum_{t=1}^T E_{\left(\mathbf{s}_t, \mathbf{a}_t\right) \sim p_\theta\left(\mathbf{s}_t, \mathbf{a}_t\right)}\left[r\left(\mathbf{s}_t, \mathbf{a}_t\right)\right] \rightarrow E_{(\mathbf{s}, \mathbf{a}) \sim p_\theta(\mathbf{s}, \mathbf{a})}[r(\mathbf{s}, \mathbf{a})]
$$</div><h3 id="value-functions">Value Functions</h3>
<p><img src="cs285.assets/image-20230910162227134.png" alt="image-20230910162227134"></p>
<p><img src="cs285.assets/image-20230910162501088.png" alt="image-20230910162501088"></p>
<h3 id="algorithms">Algorithms</h3>
<p>The anatomy of a RL Algo. is a loop of following three steps:</p>
<ul>
<li>Generate Samples (i.e. run the policy)</li>
<li>Fit a model, and then estimate the return</li>
<li>Improve the policy</li>
</ul>
<p><img src="cs285.assets/image-20230910162725476.png" alt="image-20230910162725476"></p>
<p><img src="cs285.assets/image-20230910163605865.png" alt="image-20230910163605865"></p>
<p>在考虑 sample efficiency 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>off policy 是说 sample 与 policy 无关<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>on policy 是说如果 policy 修改<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就需要生成新的 sample<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="cs285.assets/image-20230910163741440.png" alt="image-20230910163741440"></p>
<h2 id="lec-5 policy gradients">Lec 5. Policy Gradients</h2>
<p>我们考虑对 Objective 进行求梯度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$\begin{aligned}
&amp;\theta^{\star}=\arg \max _\theta \underbrace{E_{\tau \sim p_\theta(\tau)}\left[\sum_t r\left(\mathbf{s}_t, \mathbf{a}_t\right)\right]}_{J(\theta)}\\
&amp;\begin{gathered}
J(\theta)=E_{\tau \sim p_\theta(\tau)}[r(\tau)]=\int p_\theta(\tau) r(\tau) d \tau \\
\end{gathered}
\end{aligned}
$$</div><p>进行简单的代换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们有<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><img src="cs285.assets/image-20230910224304717.png" alt="image-20230910224304717"></p>
<p>由于<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$\log p_\theta(\tau)=\log p\left(\mathbf{s}_1\right)+\sum_{t=1}^T \left( \log \pi_\theta\left(\mathbf{a}_t \mid \mathbf{s}_t\right)+\log p\left(\mathbf{s}_{t+1} \mid \mathbf{s}_t, \mathbf{a}_t\right)\right)
$$</div><p>而且<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$\nabla_\theta\log p\left(\mathbf{s}_1\right) = 0, \\
\nabla_\theta\log p\left(\mathbf{s}_{t+1} \mid \mathbf{s}_t, \mathbf{a}_t\right) = 0,
$$</div><p>于是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$\nabla_\theta J(\theta)=E_{\tau \sim p_\theta(\tau)}\left[\left(\sum_{t=1}^T \nabla_\theta \log \pi_\theta\left(\mathbf{a}_t \mid \mathbf{s}_t\right)\right)\left(\sum_{t=1}^T r\left(\mathbf{s}_t, \mathbf{a}_t\right)\right)\right]
$$</div><p>然后我们可以用采样 N 个小样本作为一个 Batch 的方法来对期望值进行估计<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="cs285.assets/image-20230910224815354.png" alt="image-20230910224815354"></p>
<p><img src="cs285.assets/image-20230910225128255.png" alt="image-20230910225128255"></p>
<p>这个 formulation 在 partially observed (no states but observations) 的情况下也适用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>Policy gradient 的方法也有一定的问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>比如在下图所示<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span></p>
<p><img src="cs285.assets/image-20230910234333172.png" alt="image-20230910234333172"></p>
<p><img src="cs285.assets/image-20230910234411440.png" alt="image-20230910234411440"></p>
<p>这是 Policy gradient 方法存在的 <strong>High Variance</strong> 问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>具体来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>上述两幅图的有颜色的线段代表 sample<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>bar 代表 reward 的大小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>横轴表示 trajectory<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>蓝色的线表示在某个 Policy 下的 possibility distribution<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>上下两幅图的区别是给 reward function 加了一个常量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而这导致这次对策略的更新变得十分不稳定<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果采到的数据集足够大这个问题自然可以缓解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但在有限数据集下这个问题仍然存在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>This problem can be identified as follows. Without any a prior model of the system we’re seeking to optimize, we begin with a policy whose distribution of actions over a given state is effectively uniform. Of course, as we train the model we hope to shape the probability density so that it’s unimodal on a single action, or possibly multimodal over a few successful actions that can be taken in that state. However, acquiring this knowledge requires our model to observe the outcomes of many different actions taken in many different states. This is made exponentially worse in continuous action or state spaces as visiting even close to every state-action pair is computationally intractable.</p>
<p><strong>Variance Reduction</strong> 的有关方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这里首先介绍 <strong>reward to go</strong> 方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这个方法基于 causality<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即当 <span class="markdown-them-math-inline">$t \lt t'$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在 <span class="markdown-them-math-inline">$t$</span> 时刻获得的 reward 不会被 <span class="markdown-them-math-inline">$t'$</span> 时刻做出的策略影响<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即现在的策略的更新方向不应该与过去的 reward 有关<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这也就是说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以将 policy gradient 的 formulation 修改为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$\nabla_\theta J(\theta) \approx \frac{1}{N} \sum_{i=1}^N \sum_{t=1}^T \nabla_\theta \log \pi_\theta\left(\mathbf{a}_{i, t} \mid \mathbf{s}_{i, t}\right) \underbrace{(\sum_{t'=t}^T r\left(\mathbf{s}_{i, t^{\prime}}, \mathbf{a}_{i, t^{\prime}}\right)}_{\begin{array}{c}
\text { &quot;reward to go&quot; } \\
\hat{Q}_{i, t}
\end{array}})
$$</div><p>然后是 <strong>Baseline</strong> 方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个方法的 intuition 非常简单<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即我们让比平均更好的 policy 的 reward 是正数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不然 reward 是负数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们只需要简单修改<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><img src="cs285.assets/image-20231008024353485.png" alt="image-20231008024353485"></p>
<p>方法的正确性可以被证明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即使从 reward function 中减去了一项<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对于 policy gradient 的期望估计仍然是无偏的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>同时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们还可以通过对 policy gradient 的方差对 b 求偏导的方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>derive 出可以使 policy gradient 方差最小的 b 值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>Off-policy Policy Gradients.</strong> 上述的 Policy Gradients 方法是经典的 On-policy 方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为每次对 Policy Network 进行更新后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>都要重新采样数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为 underlying distribution of trajectories 发生了改变<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而我们在估计 <span class="markdown-them-math-inline">$\nabla_\theta J(\theta)$</span> 时需要在 <span class="markdown-them-math-inline">$E_{\tau \sim p_\theta(\tau)}$</span> 的设定下采样<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这里我们尝试解决如果我们没有从 <span class="markdown-them-math-inline">$p_\theta(\tau)$</span> 从采样的数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而只有从另一个分布 <span class="markdown-them-math-inline">$\bar{p}(\tau)$</span> 中采样的数据的问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这里的解决方法叫做 <strong>Importance Sampling</strong>.</p>
<p><img src="cs285.assets/image-20231008025328594.png" alt="image-20231008025328594"></p>
<p><img src="cs285.assets/image-20231008025458518.png" alt="image-20231008025458518"></p>
<p>这样我们可以从某个时刻的 Policy 中采样一些数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后用来优化另一个时间步的 Policy<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><img src="cs285.assets/image-20231008025847265.png" alt="image-20231008025847265"></p>
<p>我们可以再将 causality 的考量加进去<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这样得到 Off-policy 的 Policy Gradients 算法的新版本<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><img src="cs285.assets/image-20231008030141540.png" alt="image-20231008030141540"></p>
<p>但是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最后一项<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>从 t’‘=t 到 t’‘=t’<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>Importance Weight 往往因为是多个 &lt;1 的数相乘而变得很小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在实际运用时往往忽略本项<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即使忽略也不影响正确性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>会得到一个 Policy Iteration 算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="cs285.assets/image-20231008031023217.png" alt="image-20231008031023217"></p>
<p>同时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>Policy gradient 还有一些其他的数值上的问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>比如下面这个例子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><img src="cs285.assets/image-20231008034637690.png" alt="image-20231008034637690"></p>
<p>我们可知这时最优的 <span class="markdown-them-math-inline">$\theta$</span> 在 <span class="markdown-them-math-inline">$k=-1, \sigma \rightarrow 0$</span> 时取得<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但是我们可以看到右图中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>policy gradient 的方向并不总是指向 optimal solution<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这时因为在 <span class="markdown-them-math-inline">$\sigma \rightarrow 0$</span> 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于导数的数值精度问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>大部分精力用于优化 <span class="markdown-them-math-inline">$\sigma$</span> 上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>从数值分析的角度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这是只考虑了一阶导数所导致的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>下面是解决这个问题的方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们考虑一次优化的过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们现在是在 Parameter Space 搜索<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使得在一个 Step 变化不超过 <span class="markdown-them-math-inline">$\epsilon$</span> 的前提下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>寻找可以最大化 reward value 的方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>而这样做是有问题的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为有些参数的 gradient 相对于其他参数的 gradient 来说在数值意义上更加 bad-conditioned<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>于是取而代之的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们不在参数空间考虑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而是在 Policy space 上考虑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>寻找一个在 Policy 变化不大的情况下的优化 Step<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中 Policy 的变化用类似于 KL 散度的 divergence 度量来衡量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这里<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们用 KL 散度的二阶近似<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>展开结果如下图所示<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="cs285.assets/image-20231008035712021.png" alt="image-20231008035712021"></p>
<p>这里可以将结果写成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><img src="cs285.assets/image-20231008040240492.png" alt="image-20231008040240492"></p>
<p>c.f. Trust Region Policy Optimization.</p>
<h2 id="lec-6 actor-critic algorithms">Lec 6. Actor-Critic Algorithms</h2>
<p>Actor-Critic 算法基于 Policy Gradients 算法的基础上改进<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将表示 reward to go 的 Q 函数与表示状态价值的 V 函数视为可学习的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这样做是为了减少只 sample 一条或几条 trajectory 去估计 Q 和 V 时的误差<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><img src="cs285.assets/image-20231008045136911.png" alt="image-20231008045136911"></p>
<p>我们这里给出 Advantage Function <span class="markdown-them-math-inline">$A^\pi(\mathbf s_t, \mathbf a_t)$</span> 的定义如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><img src="cs285.assets/image-20231008045352674.png" alt="image-20231008045352674"></p>
<p>有了这些函数的定义后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们首先决定要去拟合其中的哪些函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们首先可以近似地将 Q 和 A 表示成 V<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><img src="cs285.assets/image-20231008050002515.png" alt="image-20231008050002515"></p>
<p><strong>Policy Evaluation.</strong> 我们接下来关注拟合 <span class="markdown-them-math-inline">$V^\pi$</span> 函数的过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个过程也被叫做 Policy Evaluation<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>比较 Naive 的拟合方法是使用 Monte Carlo evaluation<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即每次都将仿真器的状态 reset 回 <span class="markdown-them-math-inline">$\mathbf s_t$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后 rollout 多次取 reward 的平均值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们可以进一步优化这个 rollout 的过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一般叫做 bootstrapped estimate<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将考虑拟合的 V 函数 target 近似如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><img src="cs285.assets/image-20231008051058971.png" alt="image-20231008051058971"></p>
<p><strong>Discount Factors.</strong> 使用 bootstrapped estimate 去做 policy evaluation 时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果是对于 episodic 的任务可能没有很大问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但如果是对于 infinite horizon 的任务<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果每一步都用估计的 V 值的话<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可能最终会 accumulate 到正无穷<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>解决的方法是用下图所示的 simple trick, where <span class="markdown-them-math-inline">$\gamma \lt 1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><img src="cs285.assets/image-20231008052047673.png" alt="image-20231008052047673"></p>
<p>我们可以根据以上分析导出 online 的 Actor-Critic 算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><img src="cs285.assets/image-20231008053205903.png" alt="image-20231008053205903"></p>

      
    </div>
    <footer class="article-footer">
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-csarch" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a class="article-date">
  <time class="dt-published" datetime="2023-07-01T06:32:45.786Z" itemprop="datePublished">2023-07-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../categories/System/">System</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="../posts/csarch/">《计算机系统结构》 课程复习 Note</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="csarch.assets/image-20230606020658635.png" alt="image-20230606020658635"></p>
<h2 id="计算机系统结构基本概念">计算机系统结构基本概念</h2>
<p><img src="csarch.assets/image-20230606015654723.png" alt="image-20230606015654723"></p>
<p><img src="csarch.assets/image-20230612010839685.png" alt="image-20230612010839685"></p>
<p><img src="csarch.assets/image-20230612010848209.png" alt="image-20230612010848209"></p>
<p>提高并行性的技术途径<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>时间重叠 资源重复 资源共享</p>
<p>程序执行的极大值影响算术平均值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>极小值影响调和平均值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="csarch.assets/image-20230612011200470.png" alt="image-20230612011200470"></p>
<h2 id="指令系统的设计">指令系统的设计</h2>
<p><img src="csarch.assets/image-20230606021704584.png" alt="image-20230606021704584"></p>
<p>区别不同指令系统的主要因素<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span> CPU用来存储操作数的存储单元类型</p>
<p><img src="csarch.assets/image-20230606124530049.png" alt="image-20230606124530049"></p>
<p><img src="csarch.assets/image-20230606124539376.png" alt="image-20230606124539376"></p>
<p><img src="csarch.assets/image-20230606124550087.png" alt="image-20230606124550087"></p>
<p>表示操作数类型 / 寻址方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>① 编码到操作码中 ② 设置额外字段<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>硬件标识 / 地址描述符<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p>
<p><img src="csarch.assets/image-20230606125203483.png" alt="image-20230606125203483"></p>
<p><img src="csarch.assets/image-20230606024539351.png" alt="image-20230606024539351"></p>
<h2 id="流水线技术">流水线技术</h2>
<p>定位方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>直接定位方式<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>装入主存之前<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>静态定位<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>装入主存时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>动态定位<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>执行过程中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p>
<p><img src="csarch.assets/image-20230606163105726.png" alt="image-20230606163105726"></p>
<p>时空图<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>横轴<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>纵轴<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>排空时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>T=(n+k-1)t</p>
<p>连接图<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>输入-&gt;流水段1-&gt;流水寄存器-&gt;流水段2-&gt;流水寄存器-&gt;输出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p>
<p>静态与动态流水线都是多功能流水线<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>分类标准为在同一时间内<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>多功能流水线中的各段是否可以按照不同的方式连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时执行多种功能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>吞吐率</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>单位时间内流水线完成的任务数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>TP = n个任务/完成n个任务的时间T<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="csarch.assets/image-20230606184811141.png" alt="image-20230606184811141"></p>
<p>解决瓶颈问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>细分瓶颈段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>或者重复设置瓶颈段</p>
<p><strong>加速比</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>完成同样一批任务<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不使用流水线所用的时间与使用流水线所用的时间之比<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>表面上看流水线级数越多越好<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="csarch.assets/image-20230606185149575.png" alt="image-20230606185149575"></p>
<p><strong>效率</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>是指流水线的设备利用率<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在时空图上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>流水线的效率定义为n个任务占用的时空区与m个功能段总的时空区之比<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><em>做分析题的时候<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>Slides 两道例题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>注意是静态流水还是动态流水线<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></em></p>
<hr>
<p>线性与非线性流水线<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>根据流水线中是否存在反馈回路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>前者可以被连接图唯一表示<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>后者需要被连接图和预约表共同表示<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><strong>单功能非线性流水线的调度</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>预约表横向<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>向右<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>是时间<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>一般用时钟周期表示<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>纵向<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>向下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>是流水线的段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>引起非线性流水线冲突的启动距离称为<strong>禁止启动距离</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>向一条非线性流水线的输入端顺序输入两个任务之间的时间间隔称为启动距离/等待时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span> 不发生冲突的启动距离一般是一个循环数列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>称为非线性流水线的<strong>启动循环</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记作<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>7<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span> 启动距离5也可以认为是一个循环数列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>称为非线性流水线的<strong>恒定循环</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记作<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>5<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>  流水线调度目的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><strong>找出一个最小启动循环<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>按照这周期向流水线输入新任务<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>流水线的各个功能段都不会发生冲突<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而且流水线的吞吐率和效率最高</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="csarch.assets/image-20230606191658288.png" alt="image-20230606191658288"></p>
<p><img src="csarch.assets/image-20230606192137601.png" alt="image-20230606192137601"></p>
<p>下面是<strong>单功能非线性流水线调度算法</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>①由预约表得到<strong>禁止集合</strong><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>将预约表中的每一行中任意两个<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>×<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>之间的距离都计算出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>去掉重复的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由这些数形成禁止集合 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如 {2,4,6}<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p>
<p>② 由禁止集合得到冲突向量 <span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>冲突向量用一个m位的二进制数表示<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>其中m是禁止向量中的最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一般格式为 C=CmCm-1…Ci…C2C1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p>
<p>③ 由冲突向量构造调度流水线的状态图<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>将冲突向量C作为初始冲突向量送入一<br>
个m位逻辑右移移位器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>移位m次<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>n <strong>若移出的是<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用移位器中的值与初始冲突向量作<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>按位或<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>运算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到一个新的冲突向量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>n 若移出的是<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不作任何处理</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>将中间形成的每一个新的冲突向量同样处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>画出状态图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p>
<p>④ 在状态图中找出可用启动距离<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并计算平均启动距离<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>在状态图中从初始状态出发<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>能构成一种间隔拍数呈周期性重复的方案就是可用启动距离  <span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p>
<p>⑤找出平均启动距离最小的启动循环或恒定循环</p>
<p>流水线<strong>最小平均启动距离</strong>的限制范围<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>① 下限是预约表中任意一行里<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>×<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>的最多个数<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>理想最小平均启动距离<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>理想最小启动循环<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>一般恒定循环作为最小启动循环<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span> 最小平均启动距离的上限是冲突向量中1的个数再加上1 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>采用预留算法来调度非线性流水线<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以达到最优调度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>核心思想<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>通过插入非计算延迟段——修改预约表实现最小启动循环<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>每一行中与第1个<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>×<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>的距离为2的倍数的位置都要预留出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p>
<hr>
<p>指令相关<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>两条指令之间存在某种依赖关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>分为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>数据相关<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>真数据相关<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>RAW<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>名相关<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>反相关 WAR<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>输出相关 WAW<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>控制相关<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>流水线冲突<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>结构冲突<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>Stall+Bubble<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>数据冲突<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>bypassing 定向技术<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>编译器调度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>控制冲突<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>3种通过软件<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>编译器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>来减少分支延迟的方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>对分支的处理方法在程序的执行过程中始终是不变的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是静态的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>保证分支结果出来之前不能改变处理机的状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>①预测分支失败  ②预测分支成功 ③ 延迟分支  <span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p>
<p>流水线最佳段数的选择<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>平衡流水线深度与造价<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>PCR=最大吞吐量 / 流水线价格<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>求极大值点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="数据级并行-向量处理机">数据级并行 向量处理机</h2>
<p><img src="csarch.assets/image-20230607135733233.png" alt="image-20230607135733233"></p>
<p>向量平衡点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>为了使向量硬件设备和标量硬件设备利用率相等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一个程序中向量代码所占的百分比<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>向量代码:标量代码运算速度比<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>存储器-存储器型结构</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>纵向处理方式采用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>利用几个<strong>独立的存储器模块</strong>来支持向对独立的数据<strong>并发</strong>访问<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>解决数据访问冲突<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>① 将存储器个数选为质数且大于等于向量长度 ② 在运算流水线的输入端和输出端增加可变缓冲器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>寄存器-寄存器型结构</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>分组处理方式采用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>构造一个具有所要求带宽的高速寄存器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>实现高速寄存器与主寄存器之间的快速数据交换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="csarch.assets/image-20230607161526564.png" alt="image-20230607161526564"></p>
<p>CRAY-1 向量处理冲突<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>并行工作的各向量指令的源向量或结果向量使用了相同的Vi<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>或并行工作的各向量指令要使用同一个功能部件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>下面是一些提高向量处理机性能的常用技术<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>① 设置多个功能部件. ② 向量流水线冲突分析<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>指令不相关时可以并行执行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>功能部件冲突<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>源寄存器冲突<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>结果寄存器冲突都需要避免<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>③ 向量流水线<strong>链接技术</strong><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>具有<strong>先写后读</strong>相关的两条指令<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在<strong>不出现功能部件冲突和源向量冲突</strong>的情况下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以把功能部件链接起来进行流水处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>结果寄存器可作为后继指令的操作数寄存器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="csarch.assets/image-20230607163536126.png" alt="image-20230607163536126"><img src="csarch.assets/image-20230607163548423.png" alt="image-20230607163548423"></p>
<p><img src="csarch.assets/image-20230607163749897.png" alt="image-20230607163749897"></p>
<p><img src="csarch.assets/image-20230607163758252.png" alt="image-20230607163758252"></p>
<p>④ 分段开采技术<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>当向量的长度大于向量寄存器的长度时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>必须把长向量分成长度固定的段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后循环分段处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每一次循环只处理一个向量段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>先处理余数部分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后对剩下的部分分组处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>⑤ 向量的条件执行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>可以使用屏蔽向量的方式来完成条件执行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>下面介绍<strong>衡量向量处理机性能的主要参数</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p>① 向量指令的处理时间 Tvp<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果不考虑Ts<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>定义启动时间 Tstart = Tvf - 1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="csarch.assets/image-20230607164945744.png" alt="image-20230607164945744"></p>
<p>进而我们考虑<strong>一组</strong>向量指令的处理时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>把能在同一个时钟周期内一起开始执行的几条向量指令称为一个<strong>编队</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>同一个编队中的向量指令之间一定不存在流水向量功能部件的冲突和数据的冲突<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>编队后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个向量指令序列的总的执行时间为各编队的执行时间的和<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>编队时考虑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>无冲突<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果可链接则链接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>编队后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>单个编队的启动时间为编队内所有指令的启动时间的最大值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>记为 <span class="markdown-them-math-inline">$T^{i}_{\text{start}}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>所有编队的总运行时间为 <span class="markdown-them-math-inline">$\sum_i T^{i}_{\text{start}} + m n$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里 m 表示 m 个编队<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>n 是向量长度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="csarch.assets/image-20230607171010474.png" alt="image-20230607171010474"></p>
<p>然后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们再进一步考虑支持分段开采下的一组向量指令的处理时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>设 n = p * MVL + q<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里 MVL 为向量寄存器长度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>p 为商 q 为余数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由于我们需要对分段开采时引入额外的处理操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们假设这个额外的处理时间为 Tloop<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>于是余数处理的时间为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><img src="csarch.assets/image-20230607172532619.png" alt="image-20230607172532619"></p>
<p><img src="csarch.assets/image-20230607172549901.png" alt="image-20230607172549901"></p>
<p>② 最大性能 <span class="markdown-them-math-inline">$R_{\infin}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>表示当向量长度为无穷大时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>向量处理机的最高性能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也称为峰值性能.</p>
<p><img src="csarch.assets/image-20230607174800240.png" alt="image-20230607174800240"></p>
<p>③ 半性能向量长度 <span class="markdown-them-math-inline">$n_{1/2}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>半性能向量长度是指向量处理机的性能为其最大性能的一半时所需的向量长度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>评价向量流水线的建立时间对性能影响<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>④ 向量长度临界值 <span class="markdown-them-math-inline">$n_v$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对于某一计算任务而言<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>向量方式的处理速度优于标量串行方式处理速度时所需的最小向量长度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="降低指令延迟-存储系统">降低指令延迟 存储系统</h2>
<p><img src="csarch.assets/image-20230607183641564.png" alt="image-20230607183641564"></p>
<p>先注意一手每条指令 1+m 次存储器访问<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中 m 是给 L/S 指令的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>性能参数</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>① 命中率 H = N1 / (N1 + N2)<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>平均访问时间 T = H x T1 + (1-H) x T2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>② 访问效率 e = T1 / (H * T1 + (1-H) * T2) <span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>提升效率的方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>提高命中率 H<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>降低阶差 T2/T1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>③ 缺失开销 <span class="markdown-them-math-inline">$T_M = T_2 + T_B$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从下层访存时间 + 数据传输时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><span class="markdown-them-math-inline">$T_A = T_1 + (1-H) T_M$</span>.</p>
<p><img src="csarch.assets/image-20230607185746736.png" alt="image-20230607185746736"></p>
<p><img src="csarch.assets/image-20230607185736329.png" alt="image-20230607185736329"></p>
<p>Cache 所要研究的内容<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><strong>映像规则<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>查找算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>替换算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>写策略</strong></p>
<p><strong>Cache 的性能分析</strong></p>
<div class="markdown-them-math-block">$$T_\text{CPU} = \text{IC} \times (\text{CPI}_\text{exec.} + 每条指令的平均访存次数 \times (1-H) \times T_M) \times T_\text{cycle}
$$</div><p>Cache 对于低 CPI<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>高时钟频率的 CPU 来说更加重要<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>从 <span class="markdown-them-math-inline">$T_A = T_1 + (1-H) T_M$</span> 分析可知<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>提高 Cache 性能可以 (a) 降低缺失率 (b) 减少缺失开销 © 减少命中时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>三种缺失类型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>强制性缺失<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>大的 Cache block<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>容量缺失<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>冲突缺失<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>Higher associativity<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>容量为 N 的直接映象 Cache 的缺失率和容量为 N/2 的两路组相联Cache的缺失率差不多相同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>使用两级 Cache<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>减少缺失开销</p>
<ul>
<li>平均访存时间 ＝ 命中时间L1＋缺失率L1×<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>命中时间L2＋缺失率L2×缺失开销L2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
<li>局部缺失率＝该级Cache的缺失次数/到达该级Cache的访问次数</li>
<li>全局缺失率＝该级Cache的缺失次数/CPU发出的访存的总次数</li>
<li>每条指令的平均访存停顿时间＝ 每条指令的平均缺失次数L1×命中时间L2＋每条指令的平均缺失次数L2×缺失开销L</li>
</ul>
<p><img src="csarch.assets/image-20230612123723477.png" alt="image-20230612123723477"></p>
<p><img src="csarch.assets/image-20230612123730890.png" alt="image-20230612123730890"></p>
<p><img src="csarch.assets/image-20230612123738715.png" alt="image-20230612123738715"></p>
<p>然后是如何编写 Cache 友好的代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>缺失率分析<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>交换顺序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>分组<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="指令级并行-硬件方法">指令级并行 硬件方法</h2>
<p><img src="csarch.assets/image-20230608172414539.png" alt="image-20230608172414539"></p>
<p>指令集并行的硬件方法或者软件方法都是围绕着提升理想 CPI<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>解决数据冲突与控制冲突这些事情而展开的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="csarch.assets/image-20230608153303759.png" alt="image-20230608153303759"></p>
<p>代码变换与指令调度必须保持的两个关键属性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>数据流和异常行为不变</p>
<p>动态调度中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将译码阶段分成<strong>发射</strong><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>检测结构冲突<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>和<strong>读操作数</strong><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>检测数据冲突<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>两个阶段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>进入动态调度后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>会存在 WAW 和 WAR 相关的问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>同时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>动态调度还需要考虑异常是否精确的问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>下面介绍两种动态调度算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p>① **记分牌调度算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>**我们需要维护三张表<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><strong>指令执行状态表<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>功能部件状态表<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><u>结果</u>寄存器状态表</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="csarch.assets/image-20230608160415896.png" alt="image-20230608160415896"></p>
<p>下面是算法的流程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li>发射阶段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>当 功能部件可用 且 不存在 WAW 冲突 时可以发射<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>发射需要修改指令状态表的单元格<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>部件状态表的一整行<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>Rj Rk 表示是否 ready<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果不 ready 需要在 Qj Qk 填写等待的功能部件的名字<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>Fi 表示目的寄存器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>和结果寄存器的单元格<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>填写部件名字<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
<li>读操作数阶段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>当 两个操作数都已经就绪<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>Rj == yes &amp; Rk == yes<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>时读取<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>修改操作数就绪状态为 no<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且清空对应的 Qj 和 Qk<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>只修改功能部件状态表<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
<li>执行阶段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>等待功能部件执行结束<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>写结果阶段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>当 不存在 WAR 冲突<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>对于其它功能部件中的指令<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>Rj/Rk 为 yes<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且 Fj/Fk 为待写入的 Fi<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span> 时可以进入<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>此时需要清空结果寄存器状态表中结果寄存器和功能部件的对应关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>清除功能部件状态表中的对应行<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>将 Busy 置为 no<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并通过广播将等待该功能部件结果的结果就绪状态 Rj/Rk 设为 yes<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>检查功能部件表的其他行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将 Qj/Qk 为本部件的 Rj/Rk 设置为 yes<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
</ul>
<p>我们还可以通过寄存器重命名的方式来解决 WAR 相关和 WAW 相关<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>引入显式动态寄存器重命名机制<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>设置 ARF 和 PRF 并维护它们之间的映射表<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这就有了<strong>显式动态寄存器重命名的记分牌调度算法</strong><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>修改结果寄存器状态表为 ARF - PRF 映射表<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="csarch.assets/image-20230608171844980.png" alt="image-20230608171844980"></p>
<p>② **Tomasulo 调度算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>**我们首先介绍一些这个调度算法引入的硬件架构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p>(a) <strong>保留站</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>每个保留站中保存<u>若干</u>条已经发射并等待到本功能部件执行的指令的相关信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在一条指令发射到保留站的时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果该指令的源操作数已经在寄存器中就绪<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则将之取到该保留站中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果操作数还没有计算出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则在该保留站中记录将产生这个操作数的保留站的标识<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>功能部件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们引入公共数据总线<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>CDB<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>来承接所有功能部件的计算结果<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由这条总线将结果广播到所有等待操作数的保留站中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>(b) <strong>Load/Store 缓冲器</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>Load 缓冲器记录有效地址分量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>正在进行的 Load 访存地址和已经完成的 Load 结果等待广播<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>Store 缓冲器记录有效地址分量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>正在进行的 Store 目标地址<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>保存地址和数据直到存储部件接收<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>在 Tomasulo 算法中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>寄存器换名是通过保留站和发射逻辑共同完成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>当指令发射时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果其操作数还没有计算出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则将该指令中相应的寄存器号换名为将<strong>产生这个操作数的保留站的标识</strong><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>使用一个寄存器状态表来记录某个寄存器是否正在等待被某个执行部件写<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不然直接换成<strong>数据本身</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>和寄存器脱离了关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此称为<strong>隐式寄存器重命名</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这使得 Tomasulo 算法的冲突检测和指令执行控制是分布的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="csarch.assets/image-20230608174827286.png" alt="image-20230608174827286"></p>
<p>我们再详细展开一下 Tomasulo 调度算法的过程与上面的记分牌算法作对比<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们共有三个阶段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li><strong>发射</strong>阶段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>指令在 有空闲保留站 时可以发射<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>修改指令状态表<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>保留站记录行<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>如果值 Ready 直接放入 Vj / Vk<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不然在 Qj / Qk 中记录功能部件名<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>目标寄存器状态表<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对于 Load 和 Store 指令<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将保留站的 A 字段设置为偏移立即数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li><strong>执行</strong>阶段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果 Qj / Qk 均为空<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则可进入执行阶段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>Load / Store 命令除了这个条件之外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>还需要在处于缓冲队列头部时才进入执行阶段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将 A 此时替换成有效地址<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li><strong>写回</strong>阶段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>将结果广播到 CDB <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>进而影响 <em>(a)</em> 所有的保留站<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对任意 Qj / Qk 为当前 FU<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将 Qj / Qk 置空并将结果填入到 Vj / Vk <em>(b)</em> 目标寄存器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将值写入目标寄存器并释放目标寄存器状态表的表项 <em>©</em> 释放当前保留站的该指令记录项<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ul>
<p>由于这两种动态调度方式都是顺序发射<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>乱序执行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>乱序提交<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>很难实现精确异常<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>因此我们再引入 ROB 设计以允许顺序提交的出现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="csarch.assets/image-20230608182632174.png" alt="image-20230608182632174"></p>
<p>我们用 ROB 表来替换指令运行状态表<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>注意这里原来在保留站中记录的部件名<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在寄存器结果状态中记录的部件名全都换成了 ROB_IDX<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="csarch.assets/image-20230608182727962.png" alt="image-20230608182727962"></p>
<h2 id="指令级并行-软件方法">指令级并行 软件方法</h2>
<p><img src="csarch.assets/image-20230608134402068.png" alt="image-20230608134402068"></p>
<p>基本的指令调度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>使用 delay slot<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>调换指令顺序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>注意修改偏移量</p>
<p>上述基本的指令调度不能跨越基本块<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>分支指令<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不能提升有效操作<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>非控制循环和解决数据相关等待用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>比例<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此我们采取<strong>循环展开</strong>的方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这是开发循环级并行的有效方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>具体来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们<strong>把循环体的代码复制多次并按顺序排放<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后进一步消除名相关<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>进而调整循环的结束条件</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="csarch.assets/image-20230608134928763.png" alt="image-20230608134928763"></p>
<p>全局展开<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>① 注意原来 else 分支的数据相关 ② 将分支汇总的指令可以复制两份到两个不同分支中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后删除原来的指令<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>或是调度到分支之前</p>
<p><strong>静态多指令流出<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>VLIW技术</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>把同时流出的或者满足特定约束的一组操作打包在一起<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到一条更长的指令<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在VLIW处理器中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>相关检测和指令调度工作全部由编译器完成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="互连网络">互连网络</h2>
<p><img src="csarch.assets/image-20230606211636255.png" alt="image-20230606211636255"></p>
<p><strong>互连网络</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><strong>开关元件</strong>按一定<strong>拓扑结构</strong>和<strong>控制方式</strong>构成的网络以实现计算机系统内部多个处理机或多个功能部件间的相互连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>三大要素<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>互连结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>开关元件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>控制方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>互连函数</strong><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>置换函数或排列函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>通过数学表达式建立输入端号与输出端号的连接关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即在互连函数f的作用下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>输入端x连接到输出端f(x)<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>用 <span class="markdown-them-math-inline">$n =\log_2N$</span> 位二进制来表示N个输入端和输出端的二进制地址<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>介绍几种常用的基本互连函数及其主要特征<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>① 恒等函数 <span class="markdown-them-math-inline">$I(x_3x_2x_1x_0) = x_3x_2x_1x_0$</span>.</p>
<p>② 交换函数 <span class="markdown-them-math-inline">$\text{Cube}_1 (x_2x_1x_0) = x_2 \overline x_1 x_0$</span>.</p>
<p>③ 均匀洗牌函数 <span class="markdown-them-math-inline">$\sigma$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>即把输入端的二进制编号<strong>循环左移</strong>一位<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>超函数和子函数分别用 <span class="markdown-them-math-inline">$\sigma^{(k)}$</span> 和 <span class="markdown-them-math-inline">$\sigma_{(k)}$</span> 表示<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>表示对高 <span class="markdown-them-math-inline">$k$</span> 位或者低 <span class="markdown-them-math-inline">$k$</span> 位做一次循环左移<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>逆均匀洗牌函数 <span class="markdown-them-math-inline">$\sigma^{-1}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>② 与 ③ 可以组成混洗交换函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>④ 蝶式函数 <span class="markdown-them-math-inline">$\beta$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>把输入端的二进制编号的最高位与最低位互换位置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>超函数与子函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>⑤ 反位序函数 <span class="markdown-them-math-inline">$\rho$</span>​<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>将输入端二进制编号的位序颠倒过来求得相应输出端的编号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>⑥ 移数函数 <span class="markdown-them-math-inline">$\alpha_{±k}(x) = (x ± k) \mod N$</span>.</p>
<p>⑦ PM2I 函数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><span class="markdown-them-math-inline">$\text{PM2}_{±i} = (x ± 2^i ) \mod N$</span>.</p>
<p>互连网络的结构参数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>网络规模<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>网络中结点的个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>N<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>结点度 d<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>结点距离<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>两个结点间距离的最小值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>网络直径 D<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>最大结点距离<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>等分宽度 b<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>评估互连网络性能的两个基本指标<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>时延和带宽<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>互连网络通常可以分为两大类<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>① 静态互连网络<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>各结点之间有固定的连接通路<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>且在运行中不能改变的网络<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span> ② 动态互连网络<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>由交换开关构成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>可按运行程序的要求动态地改变连接状态的网络<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>下面介绍几种<strong>静态互连网络</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p>① 线性阵列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>端节点 d=1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其余结点 d=2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直径 D=N-1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>等分宽度 b=1</p>
<p>② 环<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>d=2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>b=2, 单向环 D=N<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>双向环 D=N/2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>带弦环<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>度为 k 就隔 k 个位置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>全连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>d=N-1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>D=1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>③ 循环移数网络<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>一般地<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果 <span class="markdown-them-math-inline">$| j-i|=2^r, r= 0,1,\cdots, \log_2 N$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则结点i与结点j连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这里结点度 d = 2n -1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直径 D=n/2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>网络规模 <span class="markdown-them-math-inline">$N=2^n$</span></p>
<p>⑥ 网格形<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>一个由 <span class="markdown-them-math-inline">$N=n^k$</span> 个结点构成的 <span class="markdown-them-math-inline">$k$</span> 维网格形网络<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>每维 <span class="markdown-them-math-inline">$n$</span> 个结点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>的内部结点度 <span class="markdown-them-math-inline">$d=2k$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>网络直径 <span class="markdown-them-math-inline">$D=k(n-1)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>如果 k =2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则平面网格 d=4, D=2n-2, b=n<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>规模为n×n的Illiac网络<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>d=4, D=n-1, b=2n<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>环网形<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>d=4, D=2*floor(n/2), b=2n.</p>
<p>⑦ 超立方体<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>n-立方体中结点的度都是n<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直径也是n<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>等分宽度为 <span class="markdown-them-math-inline">$b=2^{n-1}$</span>.</p>
<p><img src="csarch.assets/image-20230606225658604.png" alt="image-20230606225658604"></p>
<p><strong>动态互连网络</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>总线网络<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>交叉开关网络<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>多级互联网络<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>n输入 x n输出的开关<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>合法状态 <span class="markdown-them-math-inline">$n \times n$</span> 个<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>置换连接 <span class="markdown-them-math-inline">$n!$</span> 种<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p>
<p><img src="csarch.assets/image-20230606232915782.png" alt="image-20230606232915782"></p>
<p>多级立方体网络 N 输入<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有 <span class="markdown-them-math-inline">$\log_2 N$</span> 级别<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每级有 N/2 个 2x2 开关<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要 <span class="markdown-them-math-inline">$\log_2 N \times N /2$</span> 个 2x2 开关<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>STARAN 网络 / Omega 网络<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>(a) 4 组 2 元交换 (b) 2 组 4 元交换 © 1 组 8 元交换.</p>
<p><img src="csarch.assets/image-20230606233150199.png" alt="image-20230606233150199"></p>
<p>消息传递机制<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>当源结点和目的结点之间没有直接的连接时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>消息需要经过中间的结点进行传递<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>寻径就是用来实现这种传递的通信方法和算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有的称之为路由<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="多处理机">多处理机</h2>
<p>根据存储器的组织结构 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>把现有的 MIMD 机器分为两类<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li>集中式共享存储器结构<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>SMP<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>UMA<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
<li>分布式存储器多处理机<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>NUMA<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
</ul>
<p>我们介绍两种存储器系统结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li>共享地址空间<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>适用于分布式共享存储器系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>物理上分离的所有存储器作为一个统一的共享逻辑空间进行编址<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
<li>独立地址空间</li>
</ul>
<p>然后是通信机制<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li>共享存储器通信机制<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>共享地址空间的计算机系统采用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
<li>消息传递通信机制<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>显式地传递消息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>分为同步和异步<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
</ul>
<p>对称式共享存储器系统结构采用两种方法来解决 Cache 一致性问题<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>针对写监听协议<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li>写作废协议<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>在处理器对某个数据项进行写入之前<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>保证它拥有对该数据项的唯一的访问权<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>写更新协议<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>当一个处理器对某数据项进行写入时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过广播使其它Cache中所有对应于该数据项的副本进行更新<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ul>
<p>写作废是针对 Cache 块进行操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而写更新则是针对字<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>或字节<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>进行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>写更新协议的延迟时间较小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>分布式共享存储器系统结构寻找替代监听协议的一致性协议 —— 目录协议<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>目录<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>一种集中的数据结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对于存储器中的每一个可以调入Cache的数据块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在目录中设置一条目录项<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用于记录该块的状态以及哪些Cache中有副本等相关信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>特点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>对于任何一个数据块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>都可以快速地在唯一的一个位置中找到相关的信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>目录协议的映像方式分为 3 类<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li>全映像目录<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>每一个目录项都包含一个 N 位<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>N 为处理机的个数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>的位向量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其每一位对应于一个处理机<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>目录项的数目与处理机的个数 N 成正比<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而目录项的大小<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>位数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>也与 N 成正比<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此目录所占用的空间与 <span class="markdown-them-math-inline">$N^2$</span> 成正比<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>有限映像目录<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>限制同一数据块在所有 Cache 中的副本总数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><span class="markdown-them-math-inline">$O(N \log N)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>链式目录<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>用一个目录指针链表来表示共享集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>当一个数据块的副本数增加<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>或减少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其指针链表就跟着变长<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>或变短<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ul>
<p>多线程有两种实现方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li>细粒度<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>fine-grained<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>多线程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>在每条指令之间都能进行线程的切换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而使得多个线程可以交替执行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>粗粒度<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>coarse-grained<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>多线程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>线程之间的切换只发生在时间较长的停顿出现时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>例如第二级Cache不命中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>缺点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>减少吞吐率损失的能力有限<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>特别是对于较短的停顿来说更是如此<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>原因<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>由粗粒度多线程的流水线建立时间开销造成的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ul>
<p>同时多线程技术<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>一种在多发射<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>动态调度的处理器上同时开发线程级并行和指令级并行的技术<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在同一个时钟周期中可以发射多个线程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>理想情况下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>发射槽的利用率只受限于多个线程对资源的需求和可用资源间的不平衡<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>同时多线程只有在细粒度的实现方式下才有意义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="csarch.assets/image-20230614012119460.png" alt="image-20230614012119460"></p>

      
    </div>
    <footer class="article-footer">
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-cyber-security" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a class="article-date">
  <time class="dt-published" datetime="2023-06-30T00:00:00.000Z" itemprop="datePublished">2023-06-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../categories/Network/">Network</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="../posts/cyber-security/">《网络空间安全导论》 课程作业</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="第四章-数据加密">第四章 数据加密</h2>
<p><strong>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>公钥密码的出现解决了对称加密算法的什么问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>但对称加密至今仍被广泛使用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>请至少从一个角度简述对称加密算法未被淘汰的原因<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></strong></p>
<p>使用对称加密算法进行传输数据需要使用基于共享密钥的数据传输方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>共享密钥这一过程同样面临着被窃听的问题 —— 对称密码中<u>密钥的分发问题</u><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>从算法速度的角度上来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对称加密比公钥加密的速度快得多<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使用公钥加密传输大规模的信息会拖慢信息传输的速度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>请分别简述五种密码分析技术的大致流程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></strong></p>
<ul>
<li>唯密文攻击<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>密码分析者已知一些用相同密钥加密的多个消息的密文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其任务是尽可能恢复足够多的明文或者推算出加密消息的密钥<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>已知明文攻击<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>密码分析者已知部分明文及其对应的密文(这些密文全部用相同的密钥加密得到)<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其任务是推算出加密消息的密钥或者某种算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这种算法可以对使用该密钥加密的任意消息进行解密<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>选择明文攻击<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>密码分析者不仅已知部分明文及其对应的密文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>他们还可以选择一个或多个明文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并得到这些明文被同一密钥加密后的密文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在这种攻击中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>分析者的任务是推算出加密消息的密钥或者某种算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这种算法可以对使用该密钥加密的任意消息进行解密<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>选择密文攻击<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>密码分析者可以选择一个或多个密文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并基于相同的密钥<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到与之对应的明文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其任务是推算出加密消息的密钥<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>选择密钥攻击<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>该种攻击是选择明文攻击和选择密文攻击的结合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在这种攻击中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>基于同一个密钥<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>密码分析者不仅可以进择一个或多个明文并得到其对应的密文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>还可以选择一个或多个密文并得到其对应的明文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ul>
<p>至于具体的操作流程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>均是在对应的攻击设定下先收集足够多的输入<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>比如在选择明文攻击中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>先收集部分明文及其对应的密文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以及选择一个或多个明文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并得到这些明文被同一密钥加密后的密文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后针对这些输入做分析<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最终得出结果<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="第五章-隐私保护">第五章 隐私保护</h2>
<p><strong>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>请从基本思想<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>隐私保护水平等角度分析比较差分隐私与匿名化的不同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并举例说明</strong>.</p>
<p><strong>差分隐私</strong>在基本思想是通过针对统计输出的<u>随机化方式</u><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>比如通过查询函数的返回值中加入噪声来实现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>使攻击者无法得到查询结果间的差异<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而达到对数据集中的每个个体的隐私进行保护的效果<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>比如在查询数据集中 <span class="markdown-them-math-inline">$i$</span> 行患病的记录数量时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过先任意采样 <span class="markdown-them-math-inline">$i$</span> 行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再统计这 <span class="markdown-them-math-inline">$i$</span> 行的患病人数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而非直接返回前 <span class="markdown-them-math-inline">$i$</span> 行的患病人数来实现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>匿名化</strong>在基本思想上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>重点是<u>隐藏用户身份和数据的对应关系</u><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>比如删去表中容易关联到患者本人且研究价值不大的属性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即姓名和家庭住址<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时将姓名替换为假名等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>在隐私保护水平上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>差分隐私对隐私保护进行了严格的定义并提供了量化评估方法使不同参数处理下的数据集所提供的隐私保护水平具有可比较性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>匿名化方式则不能提供严格和科学的方法证明其隐私保护水平<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当模型参数改变时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>无法对其隐私保护水平进行定量分析<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>总之<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>与匿名化相比<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>差分隐私是一种严格的可证明的隐私保护模型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>同态加密中的半同态加密和全同态加密各指什么<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>各有何优缺点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></strong></p>
<p>半同态加密指的是仅支持加法同态<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>或乘法同态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但不是两者同时支持的的加密体制<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>全同态加密指的是同时满足加同态和乘同态性质的加密体制<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以进行任意多次加和乘运算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>全同态加密相比半同态加密加密算法功能更强大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但具有较高的计算复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>加密算法设计更复杂<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="第六章-硬件安全">第六章 硬件安全</h2>
<p><strong>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>请简要描述 Meltdown 与 Spectre 的攻击原理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并比较其共同点和区别</strong></p>
<p>Meltdown 利用了指令乱序执行只在提交重排序阶段才检测特权级违例的特点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>实现原理如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>在乱序执行的指令中加入一条加载敏感内存区域所在的页的指令<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>虽然在重排序检测时将该指令清除<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是该页被放在了缓存中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们就可以通过缓存侧信道攻击<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>提取敏感信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>Spectre 的原理是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当 CPU 发现分支预测错误时会丢弃分支执行的结果<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>恢复 CPU 的状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是不会恢复 CPU Cache 的状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>利用这一点可以突破进程间的访问限制<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而获取其他进程的数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>至于训练过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>首先训练 CPU 的分支预测单元使其在运行代码时执行特定的预测<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后使得分支预测越权访问敏感数据并将其映射到 cache 中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>进而利用缓存测信道<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过 Cache 使用情况窃取敏感数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>二者都是利用<u>缓存侧信道攻击</u>来提取敏感数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>都利用了 CPU 在架构设计上的漏洞<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>而其区别则是具体利用的漏洞不同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>Meltdown 是利用的乱序执行中违例检测的滞后性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>Spectre 是依赖于分支预测器的训练<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>请简要描述侧信道分析的原理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并简述其用于硬件木马检测的原理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></strong></p>
<p>侧信道分析是指利用硬件系统的旁路信息实施分析<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>比如利用系统的时间信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>功率消耗<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>缓存使用等来获取系统的有关信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>通过对这些侧信道信息的分析<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>攻击者可以推断出设备中的敏感信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>侧信道分析法用于硬件木马检测<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是基于<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>在芯片中植入任何恶意电路都会影响某些旁路信道的参数值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如漏电流<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>静态电源电流<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>动态功耗轨迹<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>路径延迟特性和电磁辐射等等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果存在硬件木马<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则会破坏这些旁路信道参数值的出厂时规律<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而通过侧信道分析的方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>便可以将其检测出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="第七章-操作系统安全">第七章 操作系统安全</h2>
<p><strong>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>请描述栈溢出攻击和堆溢出攻击的基本原理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></strong></p>
<p><strong>栈溢出攻击</strong>是一种攻击者越界访问并修改栈帧当中的返回地址<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以控制进程的攻击方案的总称<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>具体来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们在程序运行栈中写入超过栈帧长的数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使我们写入的数据可以覆盖掉当前栈的返回地址<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>进而在函数结束退运行栈时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>会跳转到我们覆盖后的返回地址<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>堆溢出攻击</strong>是一类攻击者越界访问并篡改堆管理数据结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>实现恶意内存读写的攻击<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>具体来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以通过构造堆块重叠或利用堆管理其他机制等方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>来实现对堆内存的任意读写<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>请简述面向返回地址编程 (ROP)和全局偏置表劫持攻击(GOT Hijacking)的原理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并分析他们能否绕过以下三种内存防御机制<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并简述原因<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></strong> <strong>a. W^X (Write XOR eXecution)</strong> <strong>b. ASLR (Address Space Layout Randomization)</strong> <strong>c. Stack Canary</strong></p>
<p><strong>ROP 攻击</strong>利用栈溢出在栈上布置一系列内存地址<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个内存地址对应一个 <code>gadget</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即以 <code>ret/jmp/call</code> 等指令结尾的一小段汇编指令<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过一个接一个的跳转从而达到控制程序执行流程的目的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><strong>GOT Hijacking 攻击</strong>通过恶意篡改 GOT 表<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将其中的函数地址修改为攻击者所指定的函数地址<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而在程序调用该函数时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>执行的实际是攻击者所指定的恶意代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>a. W^X (Write XOR eXecution)</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>本方案指定每一个内存页拥有写权限或者执行权限<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不可兼具两者<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><strong>ROP 和 GOT Hijacking 都能绕过 W^X 保护</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为虽然返回至溢出数据的栈溢出攻击失效<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但 ROP 和 GOT Hijacking 也可以不需要注入新代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而是使用程序中已有的代码片段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此不受 W^X 保护影响<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>b. ASLR  (Address Space Layout Randomization)</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>对虚拟空间当中的基地址进行随机初始化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以防止恶意代码定位进程虚拟空间当中的重要地址<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>因为目前 ASLR 的随机性不强<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且依赖模块自身的支持<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>载入应用时不会随机初始化代码段的地址与 GOT 表的地址<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是 <strong>ROP 和 GOT Hijacking 都可以绕过 ASLR 机制</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>c. Stack Canary</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>在保存的栈帧基地址<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>EBP<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>之后插入一段信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当函数返回时验证这段信息是否被修改过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><strong>对于 ROP</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当发生栈区溢出时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>攻击者为了修改返回地址<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>必须先覆盖 Stack Canary<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>造成攻击行为暴露<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>而 <strong>GOT Hijacking 则不涉及修改返回地址</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而是修改全局偏移表中的函数地址<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以<strong>可以绕过 Stack Canary 保护</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="第八章-协议栈安全">第八章 协议栈安全</h2>
<p><strong>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>请描述 IP 分片污染攻击的原理与攻击者需要具备的能力<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></strong></p>
<p>在原始报文被分片<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>传输过程中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>攻击者伪造一些分片<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>注入到正常分片流中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>篡改原始报文内容<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而形成对合法流量的污染<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>攻击者需要具备的能力<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li>源地址欺骗</li>
<li>IPID 的猜测</li>
<li>原始报文校验和的欺骗等</li>
</ul>
<p><strong>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>结合几个针对 DNS 域名服务实施的 DDoS 攻击案例分析提升 DDoS 攻击防御能力的可行措施<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></strong></p>
<p><strong>恶意服务器回复伪造攻击</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>恶意人员发送随机查询请求到 DNS 服务器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>抢在权威应答前伪造应答包发送给服务器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>修改授权资源记录<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>其成功的原因在于缺乏端节点身份和发布内容验证<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>数据未采用加密传输等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>恶意服务器回复伪造攻击</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>攻击者可依赖目标权威服务器或 DNS 软件漏洞<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>控制特定权威域名服务器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>篡改区域文件中的授权数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>形成恶意服务器回复伪造攻击<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>原因是域名系统存在复杂的解析依赖<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>DNS管理方面缺乏验证配置内容能力<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>存在错误输入的记录<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>拒绝服务攻击</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>攻击者通过控制大量用户发起 DDoS 攻击<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>耗尽 DNS 域名服务的资源<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>原因是被攻击服务器没有将这些恶意流量与正常流量区分的能力<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>提升防御能力的措施<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li>通过非对称加密验证身份 —— DNSSEC</li>
<li>DNS-over-TLS<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>DoT<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
<li>DNS-over-HTTPS (DoH)</li>
<li>安全的网络体系架构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如采用真实网络地址保障每一台接入网络计算机的安全性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>建立快速 DDoS 溯源机制</li>
<li>专用 DNS 请求过滤系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>针对 DNS 数据包进行恶意流量进行过滤</li>
<li>分布式部署降低攻击对性能的影响</li>
</ul>
<p>案例<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><a target="_blank" rel="noopener" href="http://blog.nsfocus.net/dns-ddos-attack-analysis/">http://blog.nsfocus.net/dns-ddos-attack-analysis/</a></p>
<h2 id="ch9-dns 安全">Ch9 DNS 安全</h2>
<p><strong>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>简述 DNS 缓存策略在性能提升和引入安全威胁上具有的影响<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></strong></p>
<p>DNS缓存策略通过缓存域名解析结果<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以提高访问网站的速度和性能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>当用户首次访问域名时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>DNS解析器会向域名服务器查询并获取域名的IP地址<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后将结果缓存起来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对于后续的请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果域名解析结果在缓存中存在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>解析器将直接使用缓存的结果<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>避免了重复的网络查询<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而提高了响应速度和整体性能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>DNS会有引入<strong>缓存中毒攻击</strong>的风险<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>包括本地与远程两种<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>攻击者可以对用户进行DNS欺骗攻击<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>请描述一下 DNS 基础设施中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>stub resolver, public resolver, open resolver<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>authoritative name server<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>recursive name server<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>iterative name server<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>root name server 之间的关系和区别<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></strong></p>
<ul>
<li>stub resolver<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>本地主机上运行的DNS解析工具</li>
<li>public resolver<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>ISP 提供的递归解析器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>接收用户请求并递归查询全球DNS层次结构</li>
<li>open resolver<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>接受来自任何源IP地址的DNS查询请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通常不对请求进行验证或限制<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并可能容易受到滥用</li>
<li>authoritative nameserver<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>负责存储<strong>特定域名</strong>的DNS记录的服务器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当递归解析器发起请求时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>权威名称服务器提供域名的实际解析结果</li>
<li>recursive nameserver<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>提供递归查询服务的DNS解析器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>接收来自Stub Resolver的查询请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并在DNS层次结构中逐级查询</li>
<li>iterative nameserver<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>提供迭代查询服务的DNS服务器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当递归名称服务器发起查询请求时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>迭代名称服务器会返回当前已知的最接近所需解析结果的名称服务器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>供请求方迭代查询</li>
<li>root nameserver<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>存储顶级域名的权威名称</li>
</ul>
<h2 id="ch10-真实源地址验证">Ch10 真实源地址验证</h2>
<p><strong>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>简述真实源地址认证SAVA体系结构的三个设计原则和原因<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></strong></p>
<ul>
<li>可扩展性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>应具备可扩展性以适应复杂的网络环境以及新的需求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>支持在整个互联网不同位置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>不同粒度需求的大规模部署</li>
<li>可演进<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>SAVA体系结构建立在当前互联网体系结构基础上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>整体的技术依附于现有体系结构实现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此必须要求技术对应协议与现有体系结构协议兼容<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>SAVA的部署是一个持续性的过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以会出现部分区域已经部署SAVA<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而部分区域尚未部署SAVA的情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要考虑在发展部署的过渡阶段SAVA自身的兼容性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>考虑到网络中不同运营商的存在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>SAVA体系结构还应允许运营商可以采用各自不同的实现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>SAVA系统各部分相互独立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且功能彼此不依赖</li>
<li>安全性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>SAVA体系结构的构建是支撑真实可信互联网体系结构实现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过将安全性赋予现有体系结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>弥补其信任缺失的问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以保障SAVA自身的安全性至关重要</li>
</ul>
<p><strong>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>面向地址域的真实源地址认证SAVA体系结构的三层结构是什么<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>简述每层结构的作用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></strong></p>
<ul>
<li>接入网<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>接入层面提供主机粒度的源地址验证能力<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以保证地址使用的可追溯性</li>
<li>地址域内<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>在地址域内层面提供前缀级别的保护能力<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以保护核心设备不被攻击</li>
<li>地址域间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>在地址域间层面提供地址域级别的联盟内可验证能力以及保护自身不被伪造的能力</li>
</ul>
<h2 id="ch11-公钥基础设施安全">Ch11 公钥基础设施安全</h2>
<p><strong>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>一个典型的PKI应用系统由哪几部分组成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></strong></p>
<p>PKI体系通常由终端实体用户<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>证书认证机构(CA)<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>证书注册机构(RA)和证书数据库<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以及安全服务器组成</p>
<p><strong>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>认证机构CA的职能有哪些<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></strong></p>
<ul>
<li>产生自身证书并传输给安全服务器</li>
<li>验证用户的身份<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>产生<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>分配并管理PKI结构下的所有用户的证书</li>
<li>核心功能就是发放和管理数字证书</li>
<li>负责用户证书的黑名单登记和发布</li>
</ul>
<h2 id="ch12-分布式系统安全">Ch12 分布式系统安全</h2>
<p><strong>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>请解释分布式系统当中的日蚀攻击和拜占庭节点攻击</strong></p>
<p><strong>日蚀攻击</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>针对网络节点发现以及邻居节点维护两个过程进行攻击<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使得受害节点的所有邻居节点都是由攻击者所控制的恶意节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>攻击者可以选择性的转发对攻击者有利的消息给受害者<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而配合其它网络攻击<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>攻击者可以完全隔离受害者与网络中其它节点的信息交互<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>拜占庭节点攻击</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>拜占庭节点攻击是指在分布式系统中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>存在一些恶意节点<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>拜占庭节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>的情况下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过这些节点传播错误或错误信息以破坏系统的一致性和正确性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>拜占庭节点可能会发送虚假或冲突的信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>或者完全拒绝发送信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而导致系统出现错误的决策或行为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="ch13-应用安全">Ch13 应用安全</h2>
<p><strong>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>请解释XSS攻击的原理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>简述一种防御方法并简单分析原因</strong></p>
<p>攻击原理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>跨站脚本攻击是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用户浏览该页之时嵌入其中 Web 里面的脚本代码会被执行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>防御方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>对用户输入的直接要在网页中渲染的部分进行检查和处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>转义或替换其中可执行的部分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而防止其输入以可执行的方式出现在网页中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>请解释SQL注入攻击的基本原理和防御的基本原理</strong></p>
<p>攻击原理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>SQL注入是指web应用程序对用户输入数据的合法性没有判断或过滤不严<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>导致攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>进而实现在管理员不知情的情况下实现非法操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以此来实现欺骗数据库服务器执行非授权的任意查询<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而进一步得到相应的数据信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>防御方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><strong>将数据与代码分离</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>(1) 后端代码检查输入的数据是否符合预期<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>严格限制变量的类型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>(2) 对进入数据库的特殊字符<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>'<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>&quot;<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>&lt;<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>&gt;<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>&amp;<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>*<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>;等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>进行转义处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>或编码转换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>(3) 所有的查询语句建议使用数据库提供的参数化查询接口<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即不要直接拼接 SQL 语句<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>(4) 严格限制Web应用的数据库的操作权限<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>给此用户提供仅仅能够满足其工作的最低权限<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而最大限度的减少注入攻击对数据库的危害<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="ch14-人工智能安全">Ch14 人工智能安全</h2>
<p><strong>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>请解释人工智能算法的鲁棒性和可解释性</strong></p>
<p>深度学习领域的鲁棒性可以理解为模型对数据变化的容忍度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>鲁棒性越高的模型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其识别噪声和对抗样本的准确率越高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>鲁棒性差的模型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在受到对抗攻击时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>容易给出高可信度的错误结果<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>鲁棒性差的模型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在更换数据集时<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>如训练数据更换为测试数据或投入使用时的实际数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>性能往往表现出巨大的差异<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>可解释性就是让人类了解模型做出某一决策的深层原因<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在解决现实生活中的数据科学问题时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果能够更透明地了解模型的决策过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>往往有助于人们对模型建立起一定程度的信任<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>请简述投毒攻击和对抗攻击的不同点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>请利用<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>自动驾驶<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>为场景各举一例</strong></p>
<p>数据投毒攻击在训练阶段实行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>强调的是通过混入特殊样本的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直接对模型进行修改<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而不修改测试数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对抗样本攻击在测试阶段实行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在不改变目标机器学习系统的情况下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过构造特定输入样本以完成欺骗目标系统的攻击<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>在自动驾驶场景下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>数据投毒攻击的例子为将红绿灯的标注信息反置等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对抗样本攻击为在现实世界中构造具有某种特殊样式的 pattern 使得 model 在见到这种 pattern 时会输出错误的结果<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>

      
    </div>
    <footer class="article-footer">
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a class="article-date">
  <time class="dt-published" datetime="2023-06-13T09:55:15.659Z" itemprop="datePublished">2023-06-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../categories/Journal/">Journal</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="../posts/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>又是一个学期的开始<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>从上一块 SSD 坏掉到现在已经快半年了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>终于是下定了决心将之前生成出来的静态网页换成如今这份新博客<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>虽然之前的 61 篇文档源码迷失在了宇宙深处<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但时间还早<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们还可以重新开始<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是便有了这份博客 v4 的旅程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>还记得早年作为白嫖党用 WordPress 建站后在各个免费网站托管网站与免费试用 IDC 机房之间数度搬迁<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>到现在稳定于使用 Hexo 这套成熟的建站工具<s>摆烂</s><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>心路历程也是经历了从<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>哇<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>代码好有趣<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>到<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>这个静态博客生成器只是个中小规模的项目<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>的转变<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>只可惜记录了这些成长的文档也丢进了历史的深处<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>大概之后这里还会是和之前一样的风格<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>随缘地记录一些琐碎的事情<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>不要忘了对学习新事物的热爱 :)</strong></p>
<p><img src="hello-world.assets/Pokemon.full.1518318.jpg" alt="放张图测试下灯箱效果"></p>

      
    </div>
    <footer class="article-footer">
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-os" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a class="article-date">
  <time class="dt-published" datetime="2023-06-12T11:56:41.414Z" itemprop="datePublished">2023-06-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../categories/System/">System</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="../posts/os/">《操作系统》课程复习 Note</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>结构非常混乱<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为是考试周拟合一遍所有 Slides 整合出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>目的是在考前 1h 再快速拟合一遍用的 :)</p>
<p>听说期末考试要把同步互斥那边的例子的 Code 都背下来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可怕<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="lec1-os overview">lec1 OS overview</h2>
<p>操作系统是管理硬件资源<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>控制程序运行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>改善人机界面和为应用软件提供支持的一种系统软件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>抽象<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>进程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>地址空间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>文件 – CPU<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>内存<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span> IO 设备</p>
<p>操作系统内核的特征 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>并发 共享 虚拟 异步 持久</p>
<p>单用户系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>批处理系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>多道程序系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>分时系统</p>
<p>简单结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>单体分层结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>微内核结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>外核架构<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>保护与控制分离 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>虚拟机结构</p>
<p><strong>目标三元组</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>CPU<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>操作系统和运行时库等信息</p>
<h2 id="lec3-isa trapctx & taskctx">lec3 ISA TrapCtx &amp; TaskCtx</h2>
<p>了解计算机硬件与操作系统的关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>接口/边界</p>
<p>硬件 与 OS 的 边界 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>指令集+寄存器</p>
<p>了解操作系统与应用程序的关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>接口/边界</p>
<p>系统调用和地址空间</p>
<p>了解操作系统如何隔离与限制应用程序 控制上 数据上 时间上</p>
<p>特权级机制 地址空间 中断处理 破坏隔离<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>异常处理</p>
<p><img src="os.assets/image-20230415003842612.png" alt="image-20230415003842612"></p>
<p><img src="os.assets/image-20230415113733684.png" alt="image-20230415113733684"></p>
<p><img src="os.assets/image-20230415120110727.png" alt="image-20230415120110727"></p>
<p><img src="os.assets/image-20230416151701152.png" alt="image-20230416151701152"></p>
<p>TrapContext 都有哪些内容<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>kernel sp, kernel satp, trap handler addr<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>sstatus, sepc 所有寄存器</p>
<p>什么时候会进行用户栈与内核栈的切换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>①执行完毕②做了非法的事情</p>
<p>作业与多道程序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>进程与分时多任务<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>一个具有一定独立功能的程序在一个数据集合上的一次动态执行和资源使用的过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>进程的特点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>动态性 并发性 有限度的独立性</p>
<p>进程 = 程序 + 执行状态</p>
<p>进程状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>控制流+数据</p>
<p><img src="os.assets/image-20230415122448796.png" alt="image-20230415122448796"></p>
<p><img src="os.assets/image-20230415134049728.png" alt="image-20230415134049728"></p>
<h2 id="lec5-mem">lec5 mem</h2>
<p>OS 中的内存管理方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>重定位<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>分段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>分页<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>虚拟存储</p>
<p>地址生成时机<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>编译时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>加载时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>执行时</p>
<p>内存分配方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>静态内存分配<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>动态内存分配<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>在动态内存分配中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>连续内存分配<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>非连续内存分配</p>
<p>栈动态隐式内存分配<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>堆动态显式内存分配</p>
<p>malloc free 连续</p>
<p>连续内存分配中的动态分区分配策略<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>最先匹配<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最佳匹配<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最差匹配</p>
<p>连续内存分配中的伙伴系统</p>
<p>段式存储管理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>有段表<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>位于内存中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由内核管理</p>
<p><img src="os.assets/image-20230415155712245.png" alt="image-20230415155712245"></p>
<p><img src="os.assets/image-20230416180302847.png" alt="image-20230416180302847"></p>
<h2 id="lec6-vm & replacement">lec6 vm &amp; replacement</h2>
<p>覆盖技术<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>不同时间段内执行的函数或模块共享一块有限的空间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不存在调用关系的模块可相互覆盖 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>交换技术<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>操作系统以程序为单位自动换入换出内存<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>虚拟存储<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>虚拟存储 = 内存 + 外存 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>前提是局部性原理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p>
<p>时间局部性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>一条指令的一次执行和下次执行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一个数据的一次访问和下次访问都集中在一个较短时期内</p>
<p>空间局部性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>当前指令和邻近时间的几条指令<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当前访问的数据和邻近时间访问的几个数据都集中在一个较小区域内</p>
<p>分支局部性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>一条跳转指令的两次执行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>很可能跳到相同的内存位置</p>
<p><img src="os.assets/image-20230415161827584.png" alt="image-20230415161827584"></p>
<h3 id="**局部页面置换算法**"><strong>局部页面置换算法</strong></h3>
<p>置换页面的选择范围仅限于当前进程占用的物理页面内<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>每个任务分配固定大小的物理页<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不会动态调整任务拥有的物理页数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>只考虑单个任务的内存访问情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不影响其他任务拥有的物理内存<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>最优页面置换算法 (OPT, optimal)</strong> 缺页时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>计算内存中每个逻辑页面的下一次访问时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>选择未来最长时间不访问的页面</p>
<p><strong>先进先出页面置换算法 (FIFO)</strong> 维护一个记录所有位于内存中的逻辑页面链表<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>表元素按驻留内存的时间排序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>链首最长<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>链尾最短<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>出现缺页时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>选择链首页面进行置换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>新页面加到链尾<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>分配物理页面数增加时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>缺页并不一定减少(Belady现象)</p>
<p><strong>最近最久未使用算法 (LRU, Least Recently Used)</strong>  缺页时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>计算内存中每个逻辑页面的上一次访问时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>选择上一次使用到当前时间最长的页面进行置换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>时钟页面置换算法 (Clock)</strong>  各页面组织成环形链表<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>指针指向最先调入的页面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>页面装入内存时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>访问位初始化为0  ;访问页面<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>读/写)时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>访问位置1  <span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>缺页时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从指针当前位置顺序检查 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li>访问位为0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则置换该页 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>后访问位置1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并指针移动到下一个页面 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span></li>
<li>访问位为1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则访问位置0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并指针移动到下一个页面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直到找到可置换的页面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ul>
<p><strong>改进的时钟页面置换算法</strong>  减少修改页的缺页处理开销  <span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>访问页面时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在页表项记录页面访问情况  <span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>修改页面时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在页表项记录页面修改情况  <span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>缺页时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>修改页面标志位<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以跳过有修改的页面  <span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>标志位为两位<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>读 00 -&gt; 10<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>写 00 -&gt; 11<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>最不常用置换算法 (LFU, Least Frequently Used )</strong> 缺页时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>置换访问次数最少的页面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>Belady 现象</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>分配的物理页面数增加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>缺页次数反而升高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>OPT 和 LRU 不会有 Belady<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不恢复计数的 LFU<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>FIFO 和 CLOCK 会有 Belady<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>例子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>3 / 4 页帧<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>1 2 3 4 1 2 5 1 2 3 4 5<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<blockquote>
<p>期中考完 Update<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>LFU 那道判断题竟然算没有 Belady 现象<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>明明不恢复计数的会有<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>参见 Reference 的那篇 Blog<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>去查卷也没查出个所以然<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是成功面到了 rls<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也算值了 :)</p>
</blockquote>
<h3 id="全局页面置换算法">全局页面置换算法</h3>
<p><strong>工作集页面置换算法</strong> 全局页面置换算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>可动态调整某任务拥有的物理内存大小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>影响其他任务拥有的物理内存大小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="os.assets/image-20230415170030265.png" alt="image-20230415170030265"></p>
<p><strong>常驻集<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>在当前时刻<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>进程实际驻留内存中的页面集合</strong>  <span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>工作集是进程在运行过程中的固有性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>常驻集取决于系统分配给进程的物理页面数目和页面置换算法.常驻集包括工作集时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>缺页较少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>工作集替换算法</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>每次访存换出不在工作集中的页面  <span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>缺页率页面置换算法</strong> 缺页率<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>缺页次数 / 内存访问次数 或 缺页平均时间间隔的倒数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>通过调节常驻集大小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使每个进程的缺页率保持在一个合理的范围内  <span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="os.assets/image-20230415174756635.png" alt="image-20230415174756635"></p>
<p><strong>抖动问题</strong>  由于分配给进程的物理页面太少无法包含工作集导致大量缺页而频繁置换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而进程运行速度变慢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>操作系统需在并发水平和缺页率之间达到一个平衡 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="lec7-& 8 scheduler">lec7 &amp; 8 scheduler</h2>
<p>一个具有一定独立功能的程序在某数据集合上的一次执行和资源使用的动态过程</p>
<p>任务和进程的区别<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>进程可以在运行的过程中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>创建子进程 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span> 用新的程序内容覆盖已有的程序内容<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>进程成为程序执行过程中动态申请/使用/释放各种资源的载体</p>
<p>shell 启动过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>OS 初始化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>找到 initproc执行程序并创建其 PCB<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后执行 initproc<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它执行 fork+exec user_shell<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>执行 waitpid 等待子进程</p>
<h3 id="单处理机调度">单处理机调度</h3>
<p>进程在CPU计算和I/O操作间交替<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>每次调度决定在下一个CPU计算时将哪个工作交给CPU <span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>吞吐量与延迟有 trade off<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h4 id="调度算法">调度算法</h4>
<p><strong>先来先服务调度算法FCFS</strong> 依据进程进入就绪状态的先后顺序排列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>指标是周转时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为结束时间的均值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>短作业优先调度算法SJF</strong> 选择就绪队列中执行时间最短作业/进程占用CPU进入运行状态  <span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>就绪队列按预期的执行时间来排序  <span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>最短剩余时间算法SRT</strong>  有新的进程就绪<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且新进程的服务时间小于当前进程的剩余时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则转到新的进程执行 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>抢占式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>最高响应比优先算法HRRN</strong> 选择就绪队列中响应比R值最高的进程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>R = (就绪等待时间 / 执行时间) + 1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>时间片轮转算法RR</strong>  时间片结束时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>按FCFS算法切换到下一个就绪进程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>多级队列调度算法MQ</strong>  就绪队列被划分成多个独立的子队列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>同一优先级的进程属于某个队列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且不能跨越队列</p>
<p><strong>多级反馈队列调度算法MLFQ</strong> 工作进入系统时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>放在最高优先级<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>如进程在当前的时间片没有完成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则降到下一个优先级<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>如果工作在其时间片以内主动释放CPU<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则优先级不变<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>时间片大小随优先级级别增加而增加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>经过一段时间S<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就将系统中所有工作重新加入最高优先级队列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h4 id="实时调度算法">实时调度算法</h4>
<p>Real-time OS: 正确性依赖于其时间和功能两方面的操作系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>实时操作系统的性能指标<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>时间约束的及时性<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>deadlines<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p>
<p><strong>静态优先级调度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>速率单调调度算法<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>Rate Monotonic<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></strong>  根据任务周期来确定任务优先级<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>周期越短优先级越高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>抢占式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>动态优先级调度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>最早截止时间优先算法<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>EDF, Earliest Deadline First<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></strong>  任务的优先级根据任务的截止时间动态分配<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>截止时间越短<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>优先级越高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>最低松弛度优先算法<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>LLF<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></strong>  根据任务紧急或者松弛程度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>来确定任务优先级<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>松弛度=必须完成时间-本身还需要运行时间-当前时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>优先级反置</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>高优先级进程长时间等待低优先级进程所占用资源的现象<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="os.assets/image-20230610225445360.png" alt="image-20230610225445360"></p>
<p>两种解决方案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>① <strong>优先级继承</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>占用资源的低优先级进程继承申请资源的高优先级进程的优先级<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>只在占有资源的低优先级进程被阻塞时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>才提高占有资源进程的优先级<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>② <strong>优先级天花板协议</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>占用资源进程的优先级与所有可能申请该资源的进程的最高优先级相同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>不管是否发生等待,都提升占用资源进程的优先级<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>优先级高于系统中所有被锁定的资源的优先级上限<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>任务执行临界区时就不会被阻塞<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h3 id="多处理机调度">多处理机调度</h3>
<p><img src="os.assets/image-20230610231901528.png" alt="image-20230610231901528"></p>
<p>SMP是指对称多处理器结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是指服务器中多个CPU对称工作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>无主次或从属关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>各CPU共享相同的物理内存<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个 CPU访问内存中的任何地址所需时间是相同的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此SMP也被称为一致存储器访问结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>NUMA 架构为非一致性存储器访问架构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>NUMA 服务器的基本特征是具有多个CPU模块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个CPU模块由多个CPU(如4个)组成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且具有独立的本地内存<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>I/O槽口等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>MMP 也被称为海量并行处理架构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>MPP 提供了另外一种进行系统扩展的方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它由多个SMP服务器通过一定的节点互联网络进行连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>协同工作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>完成相同的任务<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从用户的角度来看是一个服务器系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>单队列多处理器调度 SQMS<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>Multiprocessor Scheduling<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></strong>  缺乏可扩展性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>缓存亲和性弱<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>多队列多处理器调度 MQMS</strong>   每个 CPU 调度相互独立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>避免单队列方式的数据共享及同步问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可能存在负载不均衡的问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这可以通过<strong>进程迁移</strong>或者<strong>工作窃取</strong>缓解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>虽然很有意思但是 Linux 内的调度算法与历史演进过程的三节不考 :)</p>
<h2 id="lec9-fs">lec9 fs</h2>
<p>文件系统是存储设备上组织文件的方法和数据结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是管理持久性数据的子系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是操作系统中负责文件命名<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>存储和检索的子系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>文件是具有符号名<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由字节序列构成的数据项集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>文件头<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>文件系统元数据中的文件信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>UNIX类操作系统的一个设计哲学<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>一切都是文件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>文件系统的存储视图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>SuperBlock, inode, dir_entry, data block<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>文件数据块的分配方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>① 连续分配<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>高效的顺序和随机读访问<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>频繁分配会带来碎片<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>增加文件内容开销大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span> ② 链式分配<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>创建<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>增大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>缩小很容易<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>几乎没有碎片<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>随机访问效率低<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可靠性差<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>分为显式链接和隐式链接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>前者显式建立常驻内存的文件分配表 FAT 记录盘块的先后关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>隐式则是盘块中记录下一个盘块的指针<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span> ③ 索引分配<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>创建<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>增大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>缩小很容易<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>几乎没有碎片<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>支持直接访问<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>当文件很小时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>存储索引的开销相对大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p>
<p>为了处理大文件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>引入链式索引 / 多级索引的索引分配方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="os.assets/image-20230610235347956.png" alt="image-20230610235347956"></p>
<p>每次读数据需要 Read Inode, Read Data, Write Inode</p>
<p><img src="os.assets/image-20230610235355124.png" alt="image-20230610235355124"></p>
<p>如果需要创建一个新的 Inode  / Data block<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则需要对对应的 bitmap 先 R 后 W<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>创建新文件需要 write 新文件的 inode<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>父目录的 inode 和父目录的 data block<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对文件写入则需要 R Inode<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>W 数据块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>W Inode<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>多数磁盘划分为一个或多个分区<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个分区有一个独立的文件系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>崩溃一致性问题</strong><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>crash-consistency problem<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>也称一致性更新问题<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>consistent-update problem<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>特定操作需要更新磁盘上的两个结构A和B<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>磁盘一次只为一个请求提供服务<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此其中一个请求将首先到达磁盘<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>A或B<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果在一次写入完成后系统崩溃或断电<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则磁盘上的结构将处于不一致<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>inconsistent<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>的状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>文件系统检查程序 fsck 是一种修复方案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>允许不一致的事情发生<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后在重启时修复它们<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>目标<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>确保文件系统<strong>元数据</strong>内部一致<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>缺点是慢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>可能丢数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>数据日志</strong>的更新流程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ol>
<li>
<p>日志写入 Journal write<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>将事务的内容<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>包括TxB<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>元数据和数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>写入日志<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>等待这些写入完成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li>
<p>日志提交 Journal Commit<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>将事务提交块<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>包括TxE<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>写入日志<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>等待写完成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>事务被认为已提交<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>committed<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li>
<p>加检查点 Checkpoint<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>将更新内容<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>元数据和数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>写入其最终的磁盘位置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
</ol>
<p>数据日志的崩溃恢复<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li>崩溃发生在Journal Commit完成前<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>文件系统可以丢掉之前写入的log<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于磁盘具体位置的bitmap<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>inodes<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>data blocks都没变<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以可以确保文件系统一致性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>崩溃发生在Journal Commit后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>Checkpoint之前<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>文件系统在启动时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以扫描所有已经commited的log<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后针对每一个log记录操作进行replay<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即recovery的过程中执行Checkpoint<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将log的信息回写到磁盘对应的位置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这种操作也成为redo logging<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>崩溃发生在Checkpoint完成后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>那无所谓<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>都已经成功回写到磁盘了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>文件系统的bitmap<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>inodes<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>data blocks也能确保一致性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ul>
<p>日志文件系统的性能优化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>太多写<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>慢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>！</h-inner></h-char></span>从记录数据+元数据日志<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>转变成只记录元数据日志<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>不同日志模式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p>Journal Mode: 操作的metadata和file data都会写入到日志中然后提交<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这是最慢的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>Ordered Mode: 只有metadata操作会写入到日志中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是确保数据在日志提交前写入到磁盘中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>速度较快<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>Writeback Mode: 只有metadata操作会写入到日志中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且不确保数据在日志提交前写入<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>速度最快<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="lec10-& 11 ipc 线程与协程">lec10 &amp; 11 IPC 线程与协程</h2>
<p><strong>进程间通信</strong>的定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>各进程之间通过<strong>数据交换</strong><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>共享或传递<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>进行<strong>交互</strong>的行为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>分为直接通信<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>不需要 OS 中转<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>和间接通信两种方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="os.assets/image-20230610232759999.png" alt="image-20230610232759999"></p>
<img src="os.assets/image-20230610233032097.png" alt="image-20230610233032097" style="zoom: 67%;" />
<p>进程是资源<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>包括内存<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>打开的文件等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>分配的单位<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>线程是 CPU 调度的单位<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>线程是进程的一部分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>描述指令流执行状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>线程 = 进程 - 共享资源<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>线程的<strong>设计实现</strong>有以下方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li>用户态管理且用户态运行的线程<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>内核不可见的用户线程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
<li>内核态管理且用户态运行的线程</li>
<li>内核态管理且内核态运行的线程</li>
<li>双态管理的线程<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>轻量级进程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>LWP<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
</ul>
<p><img src="os.assets/image-20230610002430447.png" alt="image-20230610002430447"></p>
<p>相同进程中的线程切换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>虚拟内存是共享的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>切换时虚拟内存这些资源就保持不动<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只需要切换线程的私有数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>寄存器等不共享的数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>协程</strong>的核心思想<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>控制流的主动让出与恢复<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>无栈协程是普通函数的泛化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>优点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>协程创建成本小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>降低了内存消耗<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>协程自己的调度器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>减少了 CPU 上下文切换的开销<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>提高了 CPU 缓存命中率<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>减少同步加锁<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>整体上提高了性能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>可按照同步思维写异步代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>协程适合<strong>IO密集型</strong>场景<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>依照三个因素来对协程进行分类<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li>控制<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>控制权<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>传递机制<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>对称协程<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>等价<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span> / 非对称协程<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>调用与挂起<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
<li>栈式构造<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>有栈协程 / 无栈协程</li>
<li>编程语言中第一类<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>First-class<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>对象<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>First-class对象 / second-class对象</li>
</ul>
<p>需要切换的内容<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>进程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>页表<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>堆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>栈<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>寄存器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>线程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>栈<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>寄存器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>协程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>寄存器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="lec12-同步互斥">lec12 同步互斥</h2>
<p>临界区(Critical Section) – 访问规则</p>
<ul>
<li>空闲则入<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>没有线程在临界区时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>任何线程可进入</li>
<li>忙则等待<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>有线程在临界区时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其他线程均不能进入临界区</li>
<li>有限等待<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>等待进入临界区的线程不能无限期等待</li>
<li>让权等待<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>可选<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>不能进入临界区的线程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>应释放CPU<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>如转换到阻塞状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
</ul>
<p>同步互斥的方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li>方法1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>禁用硬件中断<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>进入临界区<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>禁止所有中断<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并保存标志<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>离开临界区<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>使能所有中断<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并恢复标志<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
<li>方法2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>基于软件的解决方法</li>
</ul>
<p><img src="os.assets/image-20230610011611010.png" alt="image-20230610011611010"></p>
<p><img src="os.assets/image-20230610011703112.png" alt="image-20230610011703112"></p>
<p><img src="os.assets/image-20230610011741228.png" alt="image-20230610011741228"></p>
<p><img src="os.assets/image-20230610011811568.png" alt="image-20230610011811568"></p>
<ul>
<li>方法3<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>更高级的抽象方法<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>锁<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使用 TestAndSet / CaS<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>自旋锁或忙等锁 v.s. 等待锁<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
</ul>
<p>信号量<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>互斥访问 和 条件同步<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>P 尝试减少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果 &lt; 0 进入等待<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则继续<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>V 是增加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果 &lt;= 0 唤醒一个等待的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>管程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>一个管程是一个基本程序单位<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是一种特殊的数据类型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中不仅有数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而且有对数据进行操作的代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="https://git.net9.org/cc7w/picgo/uploads/356bd91a2d2386a5f0647a633aa177c1/image-20230610144923717.png" alt="image-20230610144923717"></p>
<p><img src="os.assets/image-20230610144940770.png" alt="image-20230610144940770"></p>
<p><img src="os.assets/image-20230610150342525.png" alt="image-20230610150342525"></p>
<p><img src="os.assets/image-20230610150917980.png" alt="image-20230610150917980"></p>
<p><img src="os.assets/image-20230610151726858.png" alt="image-20230610151726858"></p>
<p><img src="os.assets/image-20230610152021692.png" alt="image-20230610152021692"></p>
<p><span class="bd-box"><h-char class="bd bd-end"><h-inner>【</h-inner></h-char></span>读者写者问题的信号量实现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>】</h-inner></h-char></span></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Readers%E2%80%93writers_problem#cite_note-3">https://en.wikipedia.org/wiki/Readers–writers_problem#cite_note-3</a></p>
<p><strong>读者优先</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">semaphore resource=<span class="number">1</span>;</span><br><span class="line">semaphore rmutex=<span class="number">1</span>;</span><br><span class="line">readcount=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   resource.P() is equivalent to wait(resource)</span></span><br><span class="line"><span class="comment">   resource.V() is equivalent to signal(resource)</span></span><br><span class="line"><span class="comment">   rmutex.P() is equivalent to wait(rmutex)</span></span><br><span class="line"><span class="comment">   rmutex.V() is equivalent to signal(rmutex)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">writer() &#123;</span><br><span class="line">    resource.P();          <span class="comment">//Lock the shared file for a writer</span></span><br><span class="line"></span><br><span class="line">    &lt;CRITICAL Section&gt;</span><br><span class="line">    <span class="comment">// Writing is done</span></span><br><span class="line"></span><br><span class="line">    &lt;EXIT Section&gt;</span><br><span class="line">    resource.V();          <span class="comment">//Release the shared file for use by other readers. Writers are allowed if there are no readers requesting it.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader() &#123;</span><br><span class="line">    rmutex.P();           <span class="comment">//Ensure that no other reader can execute the &lt;Entry&gt; section while you are in it</span></span><br><span class="line">    &lt;CRITICAL Section&gt;</span><br><span class="line">    readcount++;          <span class="comment">//Indicate that you are a reader trying to enter the Critical Section</span></span><br><span class="line">    <span class="keyword">if</span> (readcount == <span class="number">1</span>)   <span class="comment">//Checks if you are the first reader trying to enter CS</span></span><br><span class="line">        resource.P();     <span class="comment">//If you are the first reader, lock the resource from writers. Resource stays reserved for subsequent readers</span></span><br><span class="line">    &lt;EXIT CRITICAL Section&gt;</span><br><span class="line">    rmutex.V();           <span class="comment">//Release</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do the Reading</span></span><br><span class="line"></span><br><span class="line">    rmutex.P();           <span class="comment">//Ensure that no other reader can execute the &lt;Exit&gt; section while you are in it</span></span><br><span class="line">    &lt;CRITICAL Section&gt;</span><br><span class="line">    readcount--;          <span class="comment">//Indicate that you no longer need the shared resource. One fewer reader</span></span><br><span class="line">    <span class="keyword">if</span> (readcount == <span class="number">0</span>)   <span class="comment">//Checks if you are the last (only) reader who is reading the shared file</span></span><br><span class="line">        resource.V();     <span class="comment">//If you are last reader, then you can unlock the resource. This makes it available to writers.</span></span><br><span class="line">    &lt;EXIT CRITICAL Section&gt;</span><br><span class="line">    rmutex.V();           <span class="comment">//Release</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>写者优先</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> readcount, writecount;                   <span class="comment">//(initial value = 0)</span></span><br><span class="line">semaphore rmutex, wmutex, readTry, resource; <span class="comment">//(initial value = 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//READER</span></span><br><span class="line">reader() &#123;</span><br><span class="line">&lt;ENTRY Section&gt;</span><br><span class="line">  readTry.P();                 <span class="comment">//Indicate a reader is trying to enter</span></span><br><span class="line">  rmutex.P();                  <span class="comment">//lock entry section to avoid race condition with other readers</span></span><br><span class="line">  readcount++;                 <span class="comment">//report yourself as a reader</span></span><br><span class="line">  <span class="keyword">if</span> (readcount == <span class="number">1</span>)          <span class="comment">//checks if you are first reader</span></span><br><span class="line">    resource.P();              <span class="comment">//if you are first reader, lock the resource</span></span><br><span class="line">  rmutex.V();                  <span class="comment">//release entry section for other readers</span></span><br><span class="line">  readTry.V();                 <span class="comment">//indicate you are done trying to access the resource</span></span><br><span class="line"></span><br><span class="line">&lt;CRITICAL Section&gt;</span><br><span class="line"><span class="comment">//reading is performed</span></span><br><span class="line"></span><br><span class="line">&lt;EXIT Section&gt;</span><br><span class="line">  rmutex.P();                  <span class="comment">//reserve exit section - avoids race condition with readers</span></span><br><span class="line">  readcount--;                 <span class="comment">//indicate you&#x27;re leaving</span></span><br><span class="line">  <span class="keyword">if</span> (readcount == <span class="number">0</span>)          <span class="comment">//checks if you are last reader leaving</span></span><br><span class="line">    resource.V();              <span class="comment">//if last, you must release the locked resource</span></span><br><span class="line">  rmutex.V();                  <span class="comment">//release exit section for other readers</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//WRITER</span></span><br><span class="line">writer() &#123;</span><br><span class="line">&lt;ENTRY Section&gt;</span><br><span class="line">  wmutex.P();                  <span class="comment">//reserve entry section for writers - avoids race conditions</span></span><br><span class="line">  writecount++;                <span class="comment">//report yourself as a writer entering</span></span><br><span class="line">  <span class="keyword">if</span> (writecount == <span class="number">1</span>)         <span class="comment">//checks if you&#x27;re first writer</span></span><br><span class="line">    readTry.P();               <span class="comment">//if you&#x27;re first, then you must lock the readers out. Prevent them from trying to enter CS</span></span><br><span class="line">  wmutex.V();                  <span class="comment">//release entry section</span></span><br><span class="line">  resource.P();                <span class="comment">//reserve the resource for yourself - prevents other writers from simultaneously editing the shared resource</span></span><br><span class="line">&lt;CRITICAL Section&gt;</span><br><span class="line">  <span class="comment">//writing is performed</span></span><br><span class="line">  resource.V();                <span class="comment">//release file</span></span><br><span class="line"></span><br><span class="line">&lt;EXIT Section&gt;</span><br><span class="line">  wmutex.P();                  <span class="comment">//reserve exit section</span></span><br><span class="line">  writecount--;                <span class="comment">//indicate you&#x27;re leaving</span></span><br><span class="line">  <span class="keyword">if</span> (writecount == <span class="number">0</span>)         <span class="comment">//checks if you&#x27;re the last writer</span></span><br><span class="line">    readTry.V();               <span class="comment">//if you&#x27;re last writer, you must unlock the readers. Allows them to try enter CS for reading</span></span><br><span class="line">  wmutex.V();                  <span class="comment">//release exit section</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>保证公平防止饥饿</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> readcount;                <span class="comment">// init to 0; number of readers currently accessing resource</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// all semaphores initialised to 1</span></span><br><span class="line">semaphore resource;           <span class="comment">// controls access (read/write) to the resource. Binary semaphore.</span></span><br><span class="line">semaphore rmutex;             <span class="comment">// for syncing changes to shared variable readcount</span></span><br><span class="line">semaphore serviceQueue;       <span class="comment">// FAIRNESS: preserves ordering of requests (signaling must be FIFO)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//READER</span></span><br><span class="line">reader() &#123;</span><br><span class="line">&lt;ENTRY Section&gt;</span><br><span class="line">  serviceQueue.P();           <span class="comment">// wait in line to be serviced</span></span><br><span class="line">  rmutex.P();                 <span class="comment">// request exclusive access to readcount</span></span><br><span class="line">  readcount++;                <span class="comment">// update count of active readers</span></span><br><span class="line">  <span class="keyword">if</span> (readcount == <span class="number">1</span>)         <span class="comment">// if I am the first reader</span></span><br><span class="line">    resource.P();             <span class="comment">// request resource access for readers (writers blocked)</span></span><br><span class="line">  serviceQueue.V();           <span class="comment">// let next in line be serviced</span></span><br><span class="line">  rmutex.V();                 <span class="comment">// release access to readcount</span></span><br><span class="line">    </span><br><span class="line">&lt;CRITICAL Section&gt;</span><br><span class="line"><span class="comment">//reading is performed</span></span><br><span class="line">    </span><br><span class="line">&lt;EXIT Section&gt;</span><br><span class="line">  rmutex.P();                 <span class="comment">// request exclusive access to readcount</span></span><br><span class="line">  readcount--;                <span class="comment">// update count of active readers</span></span><br><span class="line">  <span class="keyword">if</span> (readcount == <span class="number">0</span>)         <span class="comment">// if there are no readers left</span></span><br><span class="line">    resource.V();             <span class="comment">// release resource access for all</span></span><br><span class="line">  rmutex.V();                 <span class="comment">// release access to readcount</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//WRITER</span></span><br><span class="line">writer() &#123;</span><br><span class="line">&lt;ENTRY Section&gt;</span><br><span class="line">  serviceQueue.P();           <span class="comment">// wait in line to be serviced</span></span><br><span class="line">  resource.P();               <span class="comment">// request exclusive access to resource</span></span><br><span class="line">  serviceQueue.V();           <span class="comment">// let next in line be serviced</span></span><br><span class="line">    </span><br><span class="line">&lt;CRITICAL Section&gt;</span><br><span class="line"><span class="comment">// writing is performed</span></span><br><span class="line">    </span><br><span class="line">&lt;EXIT Section&gt;</span><br><span class="line">  resource.V();               <span class="comment">// release resource access for next reader/writer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="os.assets/image-20230610152658257.png" alt="image-20230610152658257"></p>
<p><img src="os.assets/image-20230610152706036.png" alt="image-20230610152706036"></p>
<p>死锁问题 – 必要条件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li>互斥<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>任何时刻只能有一个进/线程使用一个资源实例</li>
<li>持有并等待<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>进/线程保持至少一个资源<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并正在等待获取其他进程持有的资源</li>
<li>非抢占<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>资源只能在进程使用后自愿释放</li>
<li>循环等待<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>存在等待进程集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>进程间形成相互等待资源的环</li>
</ul>
<p>死锁问题的避免<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>银行家算法</p>
<p><img src="os.assets/image-20230610155503719.png" alt="image-20230610155503719"></p>
<p><img src="os.assets/image-20230610155604440.png" alt="image-20230610155604440"></p>
<p><img src="os.assets/image-20230610155826240.png" alt="image-20230610155826240"></p>
<p>除了死锁避免算法之外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们还可以利用死锁检测与恢复<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>允许出现死锁<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>的算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>死锁检测算法与上面判断安全状态的例程相似<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但注意将 Allocation==0 的线程的 finish 直接设置为 true<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>恢复包括进程终止和资源抢占两种方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="reference">Reference</h2>
<ul>
<li>2023S <span class="bd-box"><h-char class="bd bd-end"><h-inner>《</h-inner></h-char></span>操作系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>》</h-inner></h-char></span>课程 Slides</li>
<li><a target="_blank" rel="noopener" href="https://learningos.github.io/rCore-Tutorial-Guide-2023S/index.html">https://learningos.github.io/rCore-Tutorial-Guide-2023S/index.html</a></li>
<li><a target="_blank" rel="noopener" href="https://twinkle0331.github.io/categories/Systems/">https://twinkle0331.github.io/categories/Systems/</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-license" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a class="article-date">
  <time class="dt-published" datetime="2023-06-11T16:00:54.863Z" itemprop="datePublished">2023-06-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../categories/Misc/">Misc</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="../posts/license/">常见开源协议简介</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>开源协议是为了保护软件的开发者和使用者的权益<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时促进软件的普及和发展<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>通过<strong>开源协议</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>开发者可以公开软件的源代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并<strong>对使用者授予一定的权利和自由</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时也<strong>对使用者设定一些限制</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以确保软件的持续发展和使用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>本文章我们尝试对一些常见的开源协议的内容进行梳理整合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="gplv3">GPLv3</h2>
<p>GNU GPLv3<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>GNU General Public License v3.0</p>
<blockquote>
<p>GPLv3 is <strong>viral</strong>, so it infects any replicating [modified] code with the license, such that the sources for said modifications, if any, must be available.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TL; DR ver.</span><br><span class="line">1. Anyone can copy, modify and distribute this software.</span><br><span class="line">2. You have to include the license and copyright notice with each and every distribution.</span><br><span class="line">3. You can use this software privately.</span><br><span class="line">4. You can use this software for commercial purposes.</span><br><span class="line">5. If you dare build your business solely from this code, you risk open-sourcing the whole code base.</span><br><span class="line">6. If you modify it, you have to indicate changes made to the code.</span><br><span class="line">7. Any modifications of this code base MUST be distributed with the same license, GPLv3.</span><br><span class="line">8. This software is provided without warranty.</span><br><span class="line">9. The software author or license can not be held liable for any damages inflicted by the software.</span><br></pre></td></tr></table></figure>
</blockquote>
<p><span class="bd-box"><h-char class="bd bd-end"><h-inner>【</h-inner></h-char></span>您可以…<span class="bd-box"><h-char class="bd bd-beg"><h-inner>】</h-inner></h-char></span>可商用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可对许可材料<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>licensed material, e.g. source code<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>修改<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>再分发<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可私用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>许可材料的贡献者可申请专利</p>
<p><span class="bd-box"><h-char class="bd bd-end"><h-inner>【</h-inner></h-char></span>只需要…<span class="bd-box"><h-char class="bd bd-beg"><h-inner>】</h-inner></h-char></span>再分发时需要分发源代码<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>不能仅分发可执行文件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>并标明 License<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>任何修改都要采用同一 License<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>任何修改都需指出修改处</p>
<p><span class="bd-box"><h-char class="bd bd-end"><h-inner>【</h-inner></h-char></span>免责声明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>】</h-inner></h-char></span>不保证可用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>不承担责任</p>
<h2 id="agplv3">AGPLv3</h2>
<p>GNU AGPLv3<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>GNU Affero General Public License v3.0</p>
<p>这个协议的存在是为了弥补 GPL 协议存在的<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>缺陷<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即要求软件<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>发布<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span> 才必须开源<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果是一些提供云计算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>云服务的商业模式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这里并没有涉及到软件的<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>发布<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>自然就不受 GPL 协议的约束<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>而 AGPL 协议增加了一点约束<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>如果使用 AGPL 许可的软件与用户通过网络进行交互<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则也需要满足上述 GPL 协议中的条款<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<blockquote>
<p>AGPL is like the GPL, but the GPL is only triggered if you distribute your derivative work. <strong>AGPL broadens this trigger to activate if you let people use your derivative work over a network.</strong></p>
</blockquote>
<h2 id="lgplv3">LGPLv3</h2>
<p>GNU LGPLv3<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>GNU Lesser General Public License v3.0</p>
<p>LGPL 是主要为类库<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>Libraries<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>使用而设计的开源协议<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>LGPL 允许商业软件通过动态链接方式使用 LGPL 类库而不需要开源商业软件的代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这使得采用 LGPL 协议的开源代码可以被商业软件作为类库引用并发布和销售<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>但是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果是改运行库本身<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>还需要遵守上述 GPL 协议的条款<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>仅仅是类库的调用方可以不被协议约束<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="apache-license 20">Apache License 2.0</h2>
<p><span class="bd-box"><h-char class="bd bd-end"><h-inner>【</h-inner></h-char></span>您可以…<span class="bd-box"><h-char class="bd bd-beg"><h-inner>】</h-inner></h-char></span>可商用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可对许可材料<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>licensed material, e.g. source code<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>修改<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>再分发<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可私用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>许可材料的贡献者可申请专利</p>
<p><span class="bd-box"><h-char class="bd bd-end"><h-inner>【</h-inner></h-char></span>只需要…<span class="bd-box"><h-char class="bd bd-beg"><h-inner>】</h-inner></h-char></span>再分发时需要标明 License<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>任何修改都需指出修改处</p>
<p><span class="bd-box"><h-char class="bd bd-end"><h-inner>【</h-inner></h-char></span>免责声明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>】</h-inner></h-char></span>不保证可用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>不承担责任<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>不允许注册商标</p>
<p>这个协议被 Android App 广泛使用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其再分发时不一定需要遵守同样的协议<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>简而言之<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再分发时需要给代码使用者一份同样的 License<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>如果修改了代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要在被修改的文件中说明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时必须保持原先代码中的协议<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>商标<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>专利等说明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="bsd-license">BSD License</h2>
<p>BSD 开源协议的使用需要满足以下条件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li>如果再分发的产品中包含源代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则必须带有同一份 BSD 协议<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>如果再分发的只是二进制类库/可执行文件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则需要在文档 / 版权声明中包含同一份 BSD 协议<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>不可以用开源代码的作者 / 机构名字和原来产品的名字做市场推广<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ul>
<p>在满足上述条件的基础上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使用者可以自由的使用与修改源代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也可以将修改后的代码作为开源或者专有软件再发布<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="mit-license">MIT License</h2>
<p>MIT License 相对 BSD License 更宽松<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>取消了上述<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>市场推广<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>条目的限制<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>也就是说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>除了以下两点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>MIT License 都是自由的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li>如果再分发的产品中包含源代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则必须带有同一份 MIT 协议<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>如果再分发的只是二进制类库/可执行文件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则需要在文档 / 版权声明中包含同一份 MIT 协议<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ul>
<h2 id="mozilla-public license 20">Mozilla Public License 2.0</h2>
<p><span class="bd-box"><h-char class="bd bd-end"><h-inner>【</h-inner></h-char></span>您可以…<span class="bd-box"><h-char class="bd bd-beg"><h-inner>】</h-inner></h-char></span>可商用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可对许可材料<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>licensed material, e.g. source code<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>修改<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>再分发<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可私用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>许可材料的贡献者可申请专利</p>
<p><span class="bd-box"><h-char class="bd bd-end"><h-inner>【</h-inner></h-char></span>只需要…<span class="bd-box"><h-char class="bd bd-beg"><h-inner>】</h-inner></h-char></span>再分发时必须提供源代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>需要标明 License<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使用 MPL License 的文件必须以 MPL License 再分发</p>
<p><span class="bd-box"><h-char class="bd bd-end"><h-inner>【</h-inner></h-char></span>免责声明<span class="bd-box"><h-char class="bd bd-beg"><h-inner>】</h-inner></h-char></span>不保证可用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>不承担责任<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>不允许注册商标</p>
<p>注意这里<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>使用 MPL License 的文件必须以 MPL License 再分发<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>可以允许在现有 codebase 的基础上添加一个 MPL 协议的模块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>除了这个模块需要以 MPL License 对外许可之外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>codebase 中的其他代码不需使用 MPL 协议强制对外许可<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>此外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所有再发布者都要用一个专门的文件对源代码程序修改的时间和修改的方式有描述<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="reference">Reference</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://choosealicense.com/licenses/">https://choosealicense.com/licenses/</a></li>
<li><strong><a target="_blank" rel="noopener" href="https://choosealicense.com/appendix/">https://choosealicense.com/appendix/</a></strong></li>
</ul>

      
    </div>
    <footer class="article-footer">
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-diffusion-guidance" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a class="article-date">
  <time class="dt-published" datetime="2023-06-11T16:00:42.173Z" itemprop="datePublished">2023-06-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../categories/AIGC/">AIGC</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="../posts/diffusion-guidance/">Diffusion-Guidance &amp; Latent Space</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="note:-guidance">Note: Guidance</h2>
<p>在这篇文章中我们介绍几种常见的为 Diffusion Model 添加 Guidance 的方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>所谓添加 Guidance 是说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们给定一些额外的 condition<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>如 text prompt, other images<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如何降低生成的多样性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>提高生成的准确性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>生成与这些 condition 相符的图片<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>目前常用的两种加 Guidance 的方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li>Classifier Guidance<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>通过一个 Classifier <span class="markdown-them-math-inline">$p\left(\mathbf{c} \mid \mathbf{z}_t\right)$</span> 来完成辅助的作用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>具体来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将生成过程的网络预测均值 <span class="markdown-them-math-inline">$\mu_\theta$</span> 朝着 Classifier 预测结果更加大的方向移动<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>这里的 Classifier 不一定局限于分类器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>比如在 GLIDE 中可以使用 CLIP score 来作为 Guidance 的优化目标<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只要能算梯度就可以<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
<li>Classifier-free Guidance<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>不利用 Classifier<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而是通过修改训练目标让当前 Diffusion Model 同时具有条件生成和非条件生成的能力<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ul>
<p><img src="diffusion-guidance.assets/image-20230405113800887.png" alt="DDPM"></p>
<p><img src="diffusion-guidance.assets/image-20230405113939879.png" alt="Classifier-guidance"></p>
<p><img src="diffusion-guidance.assets/image-20230405114018865.png" alt="classifier-free guidance: training"></p>
<p><img src="diffusion-guidance.assets/image-20230405123432842.png" alt="classifier-free guidance: sampling"></p>
<h3 id="classifier-guidance">Classifier Guidance</h3>
<p>正如之前说的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这种方法通过一个 Classifier <span class="markdown-them-math-inline">$p\left(\mathbf{c} \mid \mathbf{z}_t\right)$</span> 来完成辅助的作用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这种方法不需要额外训练扩散模型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而是直接在已有的 Diffusion Model 上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过 Classifier 来指导生成所期望的图像<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>我们来给出其数学推导<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>假设我们有扩散模型反向过程 <span class="markdown-them-math-inline">$p_\theta\left(x_t \mid x_{t+1}\right)$</span> <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果我们想获得 condition 在 <span class="markdown-them-math-inline">$y$</span> 上的概率分布 <span class="markdown-them-math-inline">$p_{\theta, \phi}\left(x_t \mid x_{t+1}, y\right)$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以有<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$p_{\theta, \phi}\left(x_t \mid x_{t+1}, y\right)=Z p_\theta\left(x_t \mid x_{t+1}\right) p_\phi\left(y \mid x_t\right)
$$</div><p>这里 <span class="markdown-them-math-inline">$Z$</span> 是归一化系数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>再记<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$\begin{aligned}
p_\theta\left(x_t \mid x_{t+1}\right) &amp; =\mathcal{N}(\mu, \Sigma) \\
\log p_\theta\left(x_t \mid x_{t+1}\right) &amp; =-\frac{1}{2}\left(x_t-\mu\right)^T \Sigma^{-1}\left(x_t-\mu\right)+C
\end{aligned}
$$</div><p>我们将 <span class="markdown-them-math-inline">$\log p_\phi\left(y \mid x_t\right)$</span> 在 <span class="markdown-them-math-inline">$x_t=\mu$</span> 附近做 Taylor 展开<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>有<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$\begin{aligned}
\log p_\phi\left(y \mid x_t\right) &amp; \left.\approx \log p_\phi\left(y \mid x_t\right)\right|_{x_t=\mu}+\left.\left(x_t-\mu\right) \nabla_{x_t} \log p_\phi\left(y \mid x_t\right)\right|_{x_t=\mu} \\
&amp; =C_1 + \left(x_t-\mu\right) g
\end{aligned}
$$</div><p>于是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果记 <span class="markdown-them-math-inline">$g=\left.\nabla_{x_t} \log p_\phi\left(y \mid x_t\right)\right|_{x_t=\mu}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>那么 condition 在 <span class="markdown-them-math-inline">$y$</span> 上的概率分布 <span class="markdown-them-math-inline">$p_{\theta, \phi}\left(x_t \mid x_{t+1}, y\right)$</span> 可以近似地记为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$\begin{aligned}
\log \left(p_\theta\left(x_t \mid x_{t+1}\right) p_\phi\left(y \mid x_t\right)\right) &amp; \approx-\frac{1}{2}\left(x_t-\mu\right)^T \Sigma^{-1}\left(x_t-\mu\right)+\left(x_t-\mu\right) g+C_2 \\
&amp; =-\frac{1}{2}\left(x_t-\mu-\Sigma g\right)^T \Sigma^{-1}\left(x_t-\mu-\Sigma g\right)+\frac{1}{2} g^T \Sigma g+C_2 \\
&amp; =-\frac{1}{2}\left(x_t-\mu-\Sigma g\right)^T \Sigma^{-1}\left(x_t-\mu-\Sigma g\right)+C_3 \\
&amp; =\log p(z)+C_4, z \sim \mathcal{N}(\mu+\Sigma g, \Sigma)
\end{aligned}
$$</div><p>这也就是采样过程中梯度反传的来源<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><img src="diffusion-guidance.assets/image-20230405113939879.png" alt="Classifier-guidance"></p>
<p>因为我们的 Classifier 要在带噪声的图片上做预测<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以这个 Classifier 最好不要直接用预训练好的模型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>应该用其它的数据增广方法使其具有一定的鲁棒性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>如在噪声图片上也做过训练<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p>
<h3 id="classifier-free-guidance">Classifier-free Guidance</h3>
<p>上述方法引入的 Classifier 会降低最终 Diffusion Model 的推理速度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而且如果直接使用任务的 Metric 作为 Classifier 的优化目标<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也会有拟合 Metric 的嫌疑<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这时就有了 Classifier-free 的 Guidance 方法出现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><img src="diffusion-guidance.assets/image-20230405114018865.png" alt="classifier-free guidance"></p>
<p>正如我们上面所说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>Classifier-free 的方法不引入 Classifier<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而是通过修改训练目标让当前 Diffusion Model 同时具有条件生成和非条件生成的能力<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>具体来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在<strong>训练阶段</strong>我们随机 Dropout condition <span class="markdown-them-math-inline">$\mathbf{c}$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而在<strong>测试阶段</strong>我们在生成阶段的去噪过程中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使用下式代替我们预测的噪声结果<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<div class="markdown-them-math-block">$$\tilde{\boldsymbol{\epsilon}}_\theta\left(\mathbf{z}_t, \mathbf{c}\right)=w \boldsymbol{\epsilon}_\theta\left(\mathbf{z}_t, \mathbf{c}\right)+(1-w) \boldsymbol{\epsilon}_\theta\left(\mathbf{z}_t\right)
$$</div><p>也就是说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><img src="diffusion-guidance.assets/image-20230405123429520.png" alt="image-20230405123429520"></p>
<p>如果设置 <span class="markdown-them-math-inline">$w=1$</span> 表示我们禁用了这个 Classifier-free 的 Guidance<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而在正常使用中我们一般都设置 <span class="markdown-them-math-inline">$w&gt;1$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>从隐空间的角度来看<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们实际上是在对 无条件生成时预测的噪声 和 条件生成时预测的噪声 做外插<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="latent-space">Latent Space</h2>
<p>这一节我们从 Pixel Space 前往 Latent Space<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>阐释 Stable Diffusion 模型相对于前面的 Diffusion Model 的改进<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="diffusion-guidance.assets/image-20230405175924649.png" alt="motivation"></p>
<p>首先是 Stable Diffusion 的 Motivation<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果相对一张图片进行压缩<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一般分为两个阶段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>首先是感知压缩<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>perceptual compression<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>阶段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它对应图片中的高频细节<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>而后是语义压缩<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>semantic compression<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>阶段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这个阶段更多的对应数据的语义和概念组成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>传统的 Diffusion 方法的生成阶段既要恢复语义的压缩<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>又要恢复感知层面的压缩<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此花费了大量的计算在高频细节上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>而如果我们把 Diffuse 和 Denoise 的对象改为隐空间中对语义对应的 latent code<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>便可以解决这个麻烦<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="diffusion-guidance.assets/image-20230405154930869.png" alt="Stable Diffusion"></p>
<p>于是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们首先使用 VQGAN 建模这个 pixel space 到 latent space 的转换过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我们使用一个 Encoder <span class="markdown-them-math-inline">$E$</span> 和一个 Decoder <span class="markdown-them-math-inline">$D$</span> 来建模这个转换过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在训练过程中使用重建 Loss<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>辅以计算隐空间与标准正态分布的 KL Divergence 作为隐空间正则损失<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>之后我们所有的 Diffusion 与 Denoising 过程均在隐空间中进行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>操作的具体对象是这个隐空间中的 latent code<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>至于加 condition 的方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以采用 cross attention layer 来进行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>具体来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们将 condition 用编码器 <span class="markdown-them-math-inline">$\tau_\theta$</span> 编码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>之后将 condition feature 与 latent code 之间做 cross attention<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中 Q 由 latent code 投影得到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>K 和 V 由 condition feature 投影得到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>

      
    </div>
    <footer class="article-footer">
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-diffusion-ddpm" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a class="article-date">
  <time class="dt-published" datetime="2023-06-11T16:00:38.893Z" itemprop="datePublished">2023-06-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../categories/AIGC/">AIGC</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="../posts/diffusion-ddpm/">Diffusion-DDPM</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这一系列博文我们对 Diffusion 模型进行简单的介绍 :)</p>
<p><img src="diffusion-ddpm.assets/Pasted%20image%2020230403223246.png" alt=""></p>
<p>我们认为比较重要的 Paper List<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li>重新回顾 Diffusion<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>更具多样性的生成式模型
<ul>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/1503.03585">[1503.03585]</a> Deep Unsupervised Learning using Nonequilibrium Thermodynamics (ICML’15)</li>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2006.11239">[2006.11239]</a> <strong>Denoising Diffusion Probabilistic Models</strong> (NIPS’20)</li>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2102.09672">[2102.09672]</a> Improved Denoising Diffusion Probabilistic Models (ICML’21)</li>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2010.02502">[2010.02502]</a> Denoising Diffusion Implicit Models (ICLR’21)</li>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2106.15282">[2106.15282]</a> Cascaded Diffusion Models for High Fidelity Image Generation (JMLR)</li>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2104.07636">[2104.07636]</a> Image Super-Resolution via Iterative Refinement (TPAMI)</li>
</ul>
</li>
<li>为生成添加引导
<ul>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2105.05233">[2105.05233]</a> <strong>Diffusion Models Beat GANs on Image Synthesis (NIPS’21)</strong>
<ul>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2112.10741">[2112.10741]</a> GLIDE: Towards Photorealistic Image Generation and Editing with Text-Guided Diffusion Models (ICML’22)</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2207.12598">[2207.12598]</a> <strong>Classifier-Free Diffusion Guidance (NIPS’21 Workshop)</strong></li>
</ul>
</li>
<li>Departure to Latent Space
<ul>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2112.10752v2">[2112.10752]</a> <strong>High-resolution image synthesis with latent diffusion models</strong> (CVPR’22 Oral)
<ul>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2302.05543">[2302.05543]</a> Adding Conditional Control to Text-to-Image Diffusion Models</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2204.06125">[2204.06125]</a> Hierarchical Text-Conditional Image Generation with CLIP Latents (DALL·E 2)</li>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2205.11487">[2205.11487]</a> Photorealistic Text-to-Image Diffusion Models with Deep Language Understanding (NIPS’22, Imagen)</li>
</ul>
</li>
<li>未分类<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>还没读<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>咕咕咕<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>
<ul>
<li>Zero-Shot Contrastive Loss for Text-Guided Diffusion Image Style Transfer</li>
</ul>
</li>
</ul>
<h2 id="ddpm">DDPM</h2>
<p><img src="diffusion-ddpm.assets/Pasted%20image%2020230404215439.png" alt=""></p>
<p>DDPM<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>Denoising Diffusion Probabilistic Models<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>是一种生成式模型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其可以将噪声 <span class="markdown-them-math-inline">$\mathbf{x}_T$</span> 经过一系列级联的去噪<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>Denoising<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>过程生成具有真实感的图像 <span class="markdown-them-math-inline">$\mathbf{x}_0$</span><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>在 DDPM 中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>具有两个重要的过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>前向过程<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span><em>forward process, or diffusion process</em><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>和去噪过程<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span><em>denoising process</em><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
        
          <p class="article-more-link">
            <a href="../posts/diffusion-ddpm/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="page/2/">2</a><a class="extend next" rel="next" href="page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
        <div><p><span id="busuanzi_container_site_pv">Site total view count: <span id="busuanzi_value_site_pv">Loading...</span></span></p><p>Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">Hexo</a> & Theme <a target="_blank" rel="noopener" href="https://github.com/bill-xia/hexo-theme-mashiro">Mashiro</a> & GitHub Pages</p><p>Copyright © 2020-2024 c7w. LICENSE CC BY-NC-SA 4.0.</p></div>
      
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="../index.html" class="mobile-nav-link">Home</a>
  
    <a href="../archives" class="mobile-nav-link">Posts</a>
  
    <a href="../about" class="mobile-nav-link">About</a>
  
    <a href="../friends" class="mobile-nav-link">Friends</a>
  
</nav>
    
<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="../js/clipboard.min.js"></script>
<script src="../js/jquery-1.4.3.min.js"></script>

<script src="../fancybox/jquery.fancybox-1.3.4.pack.js"></script>


<script src="../js/script.js"></script>








<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" integrity="sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" integrity="sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        {left: '$$', right: '$$', display: true},
        {left: '$', right: '$', display: false},
        {left: '\\(', right: '\\)', display: false},
        {left: '\\[', right: '\\]', display: true}
      ],
      throwOnError : false
    });
  });
</script>

  </div>
</body>
</html>