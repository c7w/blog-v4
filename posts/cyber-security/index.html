<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="codeva-kligclmjAj" />
  
  
  <title>《网络空间安全导论》 课程作业 | c7w&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="description" content="第四章 数据加密
1、公钥密码的出现解决了对称加密算法的什么问题？但对称加密至今仍被广泛使用，请至少从一个角度简述对称加密算法未被淘汰的原因？
使用对称加密算法进行传输数据需要使用基于共享密钥的数据传输方式，共享密钥这一过程同样面临着被窃听的问题 —— 对称密码中密钥的分发问题。
从算法速度的角度上">
  
  
  
    <link rel="shortcut icon" href="../../favicon.ico">
  
  <link rel="stylesheet" href="../../css/style.css">
  
    <link rel="stylesheet" href="../../fancybox/jquery.fancybox-1.3.4.css">
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <div id="nav-outer">
  <nav id="main-nav" class="outer">
    <a id="main-nav-toggle" class="nav-icon"></a>
    
      <a class="main-nav-link" href="../../index.html">Home</a>
    
      <a class="main-nav-link" href="../../archives">Posts</a>
    
      <a class="main-nav-link" href="../../about">About</a>
    
      <a class="main-nav-link" href="../../friends">Friends</a>
    
    <div class="main-nav-space-between"></div>
    
  </nav>
</div>
<!-- <div id="header-title">
  <h1 id="logo-wrap">
    <a href="../../index.html" id="logo">c7w&#39;s Blog</a>
  </h1>
  
    <h2 id="subtitle-wrap">
      <a href="../../index.html" id="subtitle">Ready for some fun stuff :)</a>
    </h2>
  
</div> -->

      <div id="content" class="outer">
        <section id="main"><article id="post-cyber-security" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a class="article-date">
  <time class="dt-published" datetime="2023-06-30T00:00:00.000Z" itemprop="datePublished">2023-06-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../../categories/Network/">Network</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      《网络空间安全导论》 课程作业
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="第四章-数据加密">第四章 数据加密</h2>
<p><strong>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>公钥密码的出现解决了对称加密算法的什么问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>但对称加密至今仍被广泛使用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>请至少从一个角度简述对称加密算法未被淘汰的原因<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></strong></p>
<p>使用对称加密算法进行传输数据需要使用基于共享密钥的数据传输方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>共享密钥这一过程同样面临着被窃听的问题 —— 对称密码中<u>密钥的分发问题</u><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>从算法速度的角度上来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对称加密比公钥加密的速度快得多<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使用公钥加密传输大规模的信息会拖慢信息传输的速度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>请分别简述五种密码分析技术的大致流程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></strong></p>
<ul>
<li>唯密文攻击<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>密码分析者已知一些用相同密钥加密的多个消息的密文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其任务是尽可能恢复足够多的明文或者推算出加密消息的密钥<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>已知明文攻击<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>密码分析者已知部分明文及其对应的密文(这些密文全部用相同的密钥加密得到)<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其任务是推算出加密消息的密钥或者某种算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这种算法可以对使用该密钥加密的任意消息进行解密<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>选择明文攻击<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>密码分析者不仅已知部分明文及其对应的密文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>他们还可以选择一个或多个明文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并得到这些明文被同一密钥加密后的密文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在这种攻击中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>分析者的任务是推算出加密消息的密钥或者某种算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这种算法可以对使用该密钥加密的任意消息进行解密<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>选择密文攻击<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>密码分析者可以选择一个或多个密文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并基于相同的密钥<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>得到与之对应的明文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其任务是推算出加密消息的密钥<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>选择密钥攻击<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>该种攻击是选择明文攻击和选择密文攻击的结合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在这种攻击中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>基于同一个密钥<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>密码分析者不仅可以进择一个或多个明文并得到其对应的密文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>还可以选择一个或多个密文并得到其对应的明文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ul>
<p>至于具体的操作流程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>均是在对应的攻击设定下先收集足够多的输入<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>比如在选择明文攻击中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>先收集部分明文及其对应的密文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以及选择一个或多个明文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并得到这些明文被同一密钥加密后的密文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后针对这些输入做分析<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最终得出结果<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="第五章-隐私保护">第五章 隐私保护</h2>
<p><strong>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>请从基本思想<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>隐私保护水平等角度分析比较差分隐私与匿名化的不同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并举例说明</strong>.</p>
<p><strong>差分隐私</strong>在基本思想是通过针对统计输出的<u>随机化方式</u><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>比如通过查询函数的返回值中加入噪声来实现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>使攻击者无法得到查询结果间的差异<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而达到对数据集中的每个个体的隐私进行保护的效果<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>比如在查询数据集中 <span class="markdown-them-math-inline">$i$</span> 行患病的记录数量时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过先任意采样 <span class="markdown-them-math-inline">$i$</span> 行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再统计这 <span class="markdown-them-math-inline">$i$</span> 行的患病人数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而非直接返回前 <span class="markdown-them-math-inline">$i$</span> 行的患病人数来实现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>匿名化</strong>在基本思想上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>重点是<u>隐藏用户身份和数据的对应关系</u><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>比如删去表中容易关联到患者本人且研究价值不大的属性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即姓名和家庭住址<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>同时将姓名替换为假名等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>在隐私保护水平上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>差分隐私对隐私保护进行了严格的定义并提供了量化评估方法使不同参数处理下的数据集所提供的隐私保护水平具有可比较性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>匿名化方式则不能提供严格和科学的方法证明其隐私保护水平<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当模型参数改变时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>无法对其隐私保护水平进行定量分析<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>总之<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>与匿名化相比<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>差分隐私是一种严格的可证明的隐私保护模型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>同态加密中的半同态加密和全同态加密各指什么<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>各有何优缺点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></strong></p>
<p>半同态加密指的是仅支持加法同态<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>或乘法同态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但不是两者同时支持的的加密体制<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>全同态加密指的是同时满足加同态和乘同态性质的加密体制<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以进行任意多次加和乘运算<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>全同态加密相比半同态加密加密算法功能更强大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但具有较高的计算复杂度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>加密算法设计更复杂<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="第六章-硬件安全">第六章 硬件安全</h2>
<p><strong>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>请简要描述 Meltdown 与 Spectre 的攻击原理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并比较其共同点和区别</strong></p>
<p>Meltdown 利用了指令乱序执行只在提交重排序阶段才检测特权级违例的特点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>实现原理如下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>在乱序执行的指令中加入一条加载敏感内存区域所在的页的指令<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>虽然在重排序检测时将该指令清除<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是该页被放在了缓存中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们就可以通过缓存侧信道攻击<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>提取敏感信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>Spectre 的原理是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当 CPU 发现分支预测错误时会丢弃分支执行的结果<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>恢复 CPU 的状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是不会恢复 CPU Cache 的状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>利用这一点可以突破进程间的访问限制<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而获取其他进程的数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>至于训练过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>首先训练 CPU 的分支预测单元使其在运行代码时执行特定的预测<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后使得分支预测越权访问敏感数据并将其映射到 cache 中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>进而利用缓存测信道<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过 Cache 使用情况窃取敏感数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>二者都是利用<u>缓存侧信道攻击</u>来提取敏感数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>都利用了 CPU 在架构设计上的漏洞<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>而其区别则是具体利用的漏洞不同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>Meltdown 是利用的乱序执行中违例检测的滞后性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>Spectre 是依赖于分支预测器的训练<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>请简要描述侧信道分析的原理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并简述其用于硬件木马检测的原理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></strong></p>
<p>侧信道分析是指利用硬件系统的旁路信息实施分析<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>比如利用系统的时间信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>功率消耗<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>缓存使用等来获取系统的有关信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>通过对这些侧信道信息的分析<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>攻击者可以推断出设备中的敏感信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>侧信道分析法用于硬件木马检测<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是基于<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>在芯片中植入任何恶意电路都会影响某些旁路信道的参数值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如漏电流<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>静态电源电流<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>动态功耗轨迹<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>路径延迟特性和电磁辐射等等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果存在硬件木马<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则会破坏这些旁路信道参数值的出厂时规律<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而通过侧信道分析的方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>便可以将其检测出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="第七章-操作系统安全">第七章 操作系统安全</h2>
<p><strong>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>请描述栈溢出攻击和堆溢出攻击的基本原理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></strong></p>
<p><strong>栈溢出攻击</strong>是一种攻击者越界访问并修改栈帧当中的返回地址<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以控制进程的攻击方案的总称<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>具体来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们在程序运行栈中写入超过栈帧长的数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使我们写入的数据可以覆盖掉当前栈的返回地址<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>进而在函数结束退运行栈时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>会跳转到我们覆盖后的返回地址<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>堆溢出攻击</strong>是一类攻击者越界访问并篡改堆管理数据结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>实现恶意内存读写的攻击<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>具体来说<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们可以通过构造堆块重叠或利用堆管理其他机制等方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>来实现对堆内存的任意读写<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>请简述面向返回地址编程 (ROP)和全局偏置表劫持攻击(GOT Hijacking)的原理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并分析他们能否绕过以下三种内存防御机制<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并简述原因<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></strong> <strong>a. W^X (Write XOR eXecution)</strong> <strong>b. ASLR (Address Space Layout Randomization)</strong> <strong>c. Stack Canary</strong></p>
<p><strong>ROP 攻击</strong>利用栈溢出在栈上布置一系列内存地址<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个内存地址对应一个 <code>gadget</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即以 <code>ret/jmp/call</code> 等指令结尾的一小段汇编指令<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过一个接一个的跳转从而达到控制程序执行流程的目的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><strong>GOT Hijacking 攻击</strong>通过恶意篡改 GOT 表<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将其中的函数地址修改为攻击者所指定的函数地址<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而在程序调用该函数时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>执行的实际是攻击者所指定的恶意代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>a. W^X (Write XOR eXecution)</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>本方案指定每一个内存页拥有写权限或者执行权限<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不可兼具两者<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><strong>ROP 和 GOT Hijacking 都能绕过 W^X 保护</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为虽然返回至溢出数据的栈溢出攻击失效<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但 ROP 和 GOT Hijacking 也可以不需要注入新代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而是使用程序中已有的代码片段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此不受 W^X 保护影响<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>b. ASLR  (Address Space Layout Randomization)</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>对虚拟空间当中的基地址进行随机初始化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以防止恶意代码定位进程虚拟空间当中的重要地址<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>因为目前 ASLR 的随机性不强<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且依赖模块自身的支持<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>载入应用时不会随机初始化代码段的地址与 GOT 表的地址<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>于是 <strong>ROP 和 GOT Hijacking 都可以绕过 ASLR 机制</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>c. Stack Canary</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>在保存的栈帧基地址<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>EBP<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>之后插入一段信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当函数返回时验证这段信息是否被修改过<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span><strong>对于 ROP</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当发生栈区溢出时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>攻击者为了修改返回地址<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>必须先覆盖 Stack Canary<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>造成攻击行为暴露<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>而 <strong>GOT Hijacking 则不涉及修改返回地址</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而是修改全局偏移表中的函数地址<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以<strong>可以绕过 Stack Canary 保护</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="第八章-协议栈安全">第八章 协议栈安全</h2>
<p><strong>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>请描述 IP 分片污染攻击的原理与攻击者需要具备的能力<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></strong></p>
<p>在原始报文被分片<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>传输过程中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>攻击者伪造一些分片<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>注入到正常分片流中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>篡改原始报文内容<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而形成对合法流量的污染<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>攻击者需要具备的能力<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li>源地址欺骗</li>
<li>IPID 的猜测</li>
<li>原始报文校验和的欺骗等</li>
</ul>
<p><strong>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>结合几个针对 DNS 域名服务实施的 DDoS 攻击案例分析提升 DDoS 攻击防御能力的可行措施<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></strong></p>
<p><strong>恶意服务器回复伪造攻击</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>恶意人员发送随机查询请求到 DNS 服务器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>抢在权威应答前伪造应答包发送给服务器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>修改授权资源记录<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>其成功的原因在于缺乏端节点身份和发布内容验证<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>数据未采用加密传输等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>恶意服务器回复伪造攻击</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>攻击者可依赖目标权威服务器或 DNS 软件漏洞<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>控制特定权威域名服务器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>篡改区域文件中的授权数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>形成恶意服务器回复伪造攻击<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>原因是域名系统存在复杂的解析依赖<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>DNS管理方面缺乏验证配置内容能力<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>存在错误输入的记录<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>拒绝服务攻击</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>攻击者通过控制大量用户发起 DDoS 攻击<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>耗尽 DNS 域名服务的资源<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>原因是被攻击服务器没有将这些恶意流量与正常流量区分的能力<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>提升防御能力的措施<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li>通过非对称加密验证身份 —— DNSSEC</li>
<li>DNS-over-TLS<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>DoT<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
<li>DNS-over-HTTPS (DoH)</li>
<li>安全的网络体系架构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如采用真实网络地址保障每一台接入网络计算机的安全性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>建立快速 DDoS 溯源机制</li>
<li>专用 DNS 请求过滤系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>针对 DNS 数据包进行恶意流量进行过滤</li>
<li>分布式部署降低攻击对性能的影响</li>
</ul>
<p>案例<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><a target="_blank" rel="noopener" href="http://blog.nsfocus.net/dns-ddos-attack-analysis/">http://blog.nsfocus.net/dns-ddos-attack-analysis/</a></p>
<h2 id="ch9-dns 安全">Ch9 DNS 安全</h2>
<p><strong>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>简述 DNS 缓存策略在性能提升和引入安全威胁上具有的影响<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></strong></p>
<p>DNS缓存策略通过缓存域名解析结果<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以提高访问网站的速度和性能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>当用户首次访问域名时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>DNS解析器会向域名服务器查询并获取域名的IP地址<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后将结果缓存起来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对于后续的请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果域名解析结果在缓存中存在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>解析器将直接使用缓存的结果<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>避免了重复的网络查询<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而提高了响应速度和整体性能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>DNS会有引入<strong>缓存中毒攻击</strong>的风险<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>包括本地与远程两种<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>攻击者可以对用户进行DNS欺骗攻击<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>请描述一下 DNS 基础设施中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>stub resolver, public resolver, open resolver<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>authoritative name server<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>recursive name server<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>iterative name server<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>root name server 之间的关系和区别<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></strong></p>
<ul>
<li>stub resolver<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>本地主机上运行的DNS解析工具</li>
<li>public resolver<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>ISP 提供的递归解析器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>接收用户请求并递归查询全球DNS层次结构</li>
<li>open resolver<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>接受来自任何源IP地址的DNS查询请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通常不对请求进行验证或限制<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并可能容易受到滥用</li>
<li>authoritative nameserver<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>负责存储<strong>特定域名</strong>的DNS记录的服务器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当递归解析器发起请求时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>权威名称服务器提供域名的实际解析结果</li>
<li>recursive nameserver<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>提供递归查询服务的DNS解析器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>接收来自Stub Resolver的查询请求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并在DNS层次结构中逐级查询</li>
<li>iterative nameserver<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>提供迭代查询服务的DNS服务器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当递归名称服务器发起查询请求时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>迭代名称服务器会返回当前已知的最接近所需解析结果的名称服务器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>供请求方迭代查询</li>
<li>root nameserver<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>存储顶级域名的权威名称</li>
</ul>
<h2 id="ch10-真实源地址验证">Ch10 真实源地址验证</h2>
<p><strong>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>简述真实源地址认证SAVA体系结构的三个设计原则和原因<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></strong></p>
<ul>
<li>可扩展性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>应具备可扩展性以适应复杂的网络环境以及新的需求<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>支持在整个互联网不同位置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>不同粒度需求的大规模部署</li>
<li>可演进<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>SAVA体系结构建立在当前互联网体系结构基础上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>整体的技术依附于现有体系结构实现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此必须要求技术对应协议与现有体系结构协议兼容<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>SAVA的部署是一个持续性的过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以会出现部分区域已经部署SAVA<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而部分区域尚未部署SAVA的情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>需要考虑在发展部署的过渡阶段SAVA自身的兼容性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>考虑到网络中不同运营商的存在<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>SAVA体系结构还应允许运营商可以采用各自不同的实现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>SAVA系统各部分相互独立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且功能彼此不依赖</li>
<li>安全性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>SAVA体系结构的构建是支撑真实可信互联网体系结构实现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过将安全性赋予现有体系结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>弥补其信任缺失的问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以保障SAVA自身的安全性至关重要</li>
</ul>
<p><strong>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>面向地址域的真实源地址认证SAVA体系结构的三层结构是什么<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>简述每层结构的作用<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></strong></p>
<ul>
<li>接入网<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>接入层面提供主机粒度的源地址验证能力<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以保证地址使用的可追溯性</li>
<li>地址域内<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>在地址域内层面提供前缀级别的保护能力<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以保护核心设备不被攻击</li>
<li>地址域间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>在地址域间层面提供地址域级别的联盟内可验证能力以及保护自身不被伪造的能力</li>
</ul>
<h2 id="ch11-公钥基础设施安全">Ch11 公钥基础设施安全</h2>
<p><strong>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>一个典型的PKI应用系统由哪几部分组成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></strong></p>
<p>PKI体系通常由终端实体用户<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>证书认证机构(CA)<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>证书注册机构(RA)和证书数据库<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以及安全服务器组成</p>
<p><strong>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>认证机构CA的职能有哪些<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span></strong></p>
<ul>
<li>产生自身证书并传输给安全服务器</li>
<li>验证用户的身份<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>产生<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>分配并管理PKI结构下的所有用户的证书</li>
<li>核心功能就是发放和管理数字证书</li>
<li>负责用户证书的黑名单登记和发布</li>
</ul>
<h2 id="ch12-分布式系统安全">Ch12 分布式系统安全</h2>
<p><strong>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>请解释分布式系统当中的日蚀攻击和拜占庭节点攻击</strong></p>
<p><strong>日蚀攻击</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>针对网络节点发现以及邻居节点维护两个过程进行攻击<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使得受害节点的所有邻居节点都是由攻击者所控制的恶意节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>攻击者可以选择性的转发对攻击者有利的消息给受害者<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而配合其它网络攻击<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>攻击者可以完全隔离受害者与网络中其它节点的信息交互<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>拜占庭节点攻击</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>拜占庭节点攻击是指在分布式系统中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>存在一些恶意节点<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>拜占庭节点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>的情况下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过这些节点传播错误或错误信息以破坏系统的一致性和正确性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>拜占庭节点可能会发送虚假或冲突的信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>或者完全拒绝发送信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而导致系统出现错误的决策或行为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="ch13-应用安全">Ch13 应用安全</h2>
<p><strong>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>请解释XSS攻击的原理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>简述一种防御方法并简单分析原因</strong></p>
<p>攻击原理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>跨站脚本攻击是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用户浏览该页之时嵌入其中 Web 里面的脚本代码会被执行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>防御方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>对用户输入的直接要在网页中渲染的部分进行检查和处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>转义或替换其中可执行的部分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而防止其输入以可执行的方式出现在网页中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>请解释SQL注入攻击的基本原理和防御的基本原理</strong></p>
<p>攻击原理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>SQL注入是指web应用程序对用户输入数据的合法性没有判断或过滤不严<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>导致攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>进而实现在管理员不知情的情况下实现非法操作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以此来实现欺骗数据库服务器执行非授权的任意查询<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而进一步得到相应的数据信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>防御方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><strong>将数据与代码分离</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>(1) 后端代码检查输入的数据是否符合预期<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>严格限制变量的类型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>(2) 对进入数据库的特殊字符<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>'<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>&quot;<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>&lt;<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>&gt;<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>&amp;<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>*<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>;等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>进行转义处理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>或编码转换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>(3) 所有的查询语句建议使用数据库提供的参数化查询接口<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即不要直接拼接 SQL 语句<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>(4) 严格限制Web应用的数据库的操作权限<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>给此用户提供仅仅能够满足其工作的最低权限<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而最大限度的减少注入攻击对数据库的危害<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="ch14-人工智能安全">Ch14 人工智能安全</h2>
<p><strong>1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>请解释人工智能算法的鲁棒性和可解释性</strong></p>
<p>深度学习领域的鲁棒性可以理解为模型对数据变化的容忍度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>鲁棒性越高的模型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其识别噪声和对抗样本的准确率越高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>鲁棒性差的模型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在受到对抗攻击时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>容易给出高可信度的错误结果<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>鲁棒性差的模型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在更换数据集时<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>如训练数据更换为测试数据或投入使用时的实际数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>性能往往表现出巨大的差异<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>可解释性就是让人类了解模型做出某一决策的深层原因<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>在解决现实生活中的数据科学问题时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果能够更透明地了解模型的决策过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>往往有助于人们对模型建立起一定程度的信任<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>请简述投毒攻击和对抗攻击的不同点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>请利用<span class="bd-box"><h-char class="bd bd-end"><h-inner>“</h-inner></h-char></span>自动驾驶<span class="bd-box"><h-char class="bd bd-beg"><h-inner>”</h-inner></h-char></span>为场景各举一例</strong></p>
<p>数据投毒攻击在训练阶段实行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>强调的是通过混入特殊样本的形式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直接对模型进行修改<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而不修改测试数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对抗样本攻击在测试阶段实行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在不改变目标机器学习系统的情况下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>通过构造特定输入样本以完成欺骗目标系统的攻击<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>在自动驾驶场景下<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>数据投毒攻击的例子为将红绿灯的标注信息反置等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>对抗样本攻击为在现实世界中构造具有某种特殊样式的 pattern 使得 model 在见到这种 pattern 时会输出错误的结果<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>

      
    </div>
    <footer class="article-footer">
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="../diffusion-dpo/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Diffusion-DPO 公式推导
        
      </div>
    </a>
  
  
    <a href="../cs285/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">
        
          Note for CS 285, Deep Reinforcement Learning
        
      </div>
    </a>
  
</nav>

  
</article>


</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
        <div><p><span id="busuanzi_container_site_pv">Site total view count: <span id="busuanzi_value_site_pv">Loading...</span></span></p><p>Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">Hexo</a> & Theme <a target="_blank" rel="noopener" href="https://github.com/bill-xia/hexo-theme-mashiro">Mashiro</a> & GitHub Pages</p><p>Copyright © 2020-2024 c7w. LICENSE CC BY-NC-SA 4.0.</p></div>
      
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="../../index.html" class="mobile-nav-link">Home</a>
  
    <a href="../../archives" class="mobile-nav-link">Posts</a>
  
    <a href="../../about" class="mobile-nav-link">About</a>
  
    <a href="../../friends" class="mobile-nav-link">Friends</a>
  
</nav>
    
<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="../../js/clipboard.min.js"></script>
<script src="../../js/jquery-1.4.3.min.js"></script>

<script src="../../fancybox/jquery.fancybox-1.3.4.pack.js"></script>


<script src="../../js/script.js"></script>








<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" integrity="sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" integrity="sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        {left: '$$', right: '$$', display: true},
        {left: '$', right: '$', display: false},
        {left: '\\(', right: '\\)', display: false},
        {left: '\\[', right: '\\]', display: true}
      ],
      throwOnError : false
    });
  });
</script>

  </div>
</body>
</html>