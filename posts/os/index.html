<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="codeva-kligclmjAj" />
  
  
  <title>《操作系统》课程复习 Note | c7w&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="description" content="结构非常混乱，因为是考试周拟合一遍所有 Slides 整合出来，目的是在考前 1h 再快速拟合一遍用的 :)
听说期末考试要把同步互斥那边的例子的 Code 都背下来，可怕。
lec1 OS overview
操作系统是管理硬件资源、控制程序运行、改善人机界面和为应用软件提供支持的一种系统软件。
抽">
  
  
  
    <link rel="shortcut icon" href="../../favicon.ico">
  
  <link rel="stylesheet" href="../../css/style.css">
  
    <link rel="stylesheet" href="../../fancybox/jquery.fancybox-1.3.4.css">
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <div id="nav-outer">
  <nav id="main-nav" class="outer">
    <a id="main-nav-toggle" class="nav-icon"></a>
    
      <a class="main-nav-link" href="../../index.html">Home</a>
    
      <a class="main-nav-link" href="../../archives">Posts</a>
    
      <a class="main-nav-link" href="../../about">About</a>
    
      <a class="main-nav-link" href="../../friends">Friends</a>
    
    <div class="main-nav-space-between"></div>
    
  </nav>
</div>
<!-- <div id="header-title">
  <h1 id="logo-wrap">
    <a href="../../index.html" id="logo">c7w&#39;s Blog</a>
  </h1>
  
    <h2 id="subtitle-wrap">
      <a href="../../index.html" id="subtitle">Ready for some fun stuff :)</a>
    </h2>
  
</div> -->

      <div id="content" class="outer">
        <section id="main"><article id="post-os" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a class="article-date">
  <time class="dt-published" datetime="2023-06-12T11:56:41.414Z" itemprop="datePublished">2023-06-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../../categories/System/">System</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      《操作系统》课程复习 Note
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>结构非常混乱<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为是考试周拟合一遍所有 Slides 整合出来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>目的是在考前 1h 再快速拟合一遍用的 :)</p>
<p>听说期末考试要把同步互斥那边的例子的 Code 都背下来<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可怕<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="lec1-os overview">lec1 OS overview</h2>
<p>操作系统是管理硬件资源<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>控制程序运行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>改善人机界面和为应用软件提供支持的一种系统软件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>抽象<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>进程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>地址空间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>文件 – CPU<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>内存<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span> IO 设备</p>
<p>操作系统内核的特征 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>并发 共享 虚拟 异步 持久</p>
<p>单用户系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>批处理系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>多道程序系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>分时系统</p>
<p>简单结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>单体分层结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>微内核结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>外核架构<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>保护与控制分离 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>虚拟机结构</p>
<p><strong>目标三元组</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>CPU<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>操作系统和运行时库等信息</p>
<h2 id="lec3-isa trapctx & taskctx">lec3 ISA TrapCtx &amp; TaskCtx</h2>
<p>了解计算机硬件与操作系统的关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>接口/边界</p>
<p>硬件 与 OS 的 边界 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>指令集+寄存器</p>
<p>了解操作系统与应用程序的关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>接口/边界</p>
<p>系统调用和地址空间</p>
<p>了解操作系统如何隔离与限制应用程序 控制上 数据上 时间上</p>
<p>特权级机制 地址空间 中断处理 破坏隔离<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>异常处理</p>
<p><img src="os.assets/image-20230415003842612.png" alt="image-20230415003842612"></p>
<p><img src="os.assets/image-20230415113733684.png" alt="image-20230415113733684"></p>
<p><img src="os.assets/image-20230415120110727.png" alt="image-20230415120110727"></p>
<p><img src="os.assets/image-20230416151701152.png" alt="image-20230416151701152"></p>
<p>TrapContext 都有哪些内容<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>kernel sp, kernel satp, trap handler addr<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>sstatus, sepc 所有寄存器</p>
<p>什么时候会进行用户栈与内核栈的切换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>①执行完毕②做了非法的事情</p>
<p>作业与多道程序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>进程与分时多任务<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>一个具有一定独立功能的程序在一个数据集合上的一次动态执行和资源使用的过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>进程的特点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>动态性 并发性 有限度的独立性</p>
<p>进程 = 程序 + 执行状态</p>
<p>进程状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>控制流+数据</p>
<p><img src="os.assets/image-20230415122448796.png" alt="image-20230415122448796"></p>
<p><img src="os.assets/image-20230415134049728.png" alt="image-20230415134049728"></p>
<h2 id="lec5-mem">lec5 mem</h2>
<p>OS 中的内存管理方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>重定位<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>分段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>分页<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>虚拟存储</p>
<p>地址生成时机<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>编译时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>加载时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>执行时</p>
<p>内存分配方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>静态内存分配<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>动态内存分配<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>在动态内存分配中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>连续内存分配<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>非连续内存分配</p>
<p>栈动态隐式内存分配<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>堆动态显式内存分配</p>
<p>malloc free 连续</p>
<p>连续内存分配中的动态分区分配策略<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>最先匹配<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最佳匹配<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>最差匹配</p>
<p>连续内存分配中的伙伴系统</p>
<p>段式存储管理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>有段表<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>位于内存中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由内核管理</p>
<p><img src="os.assets/image-20230415155712245.png" alt="image-20230415155712245"></p>
<p><img src="os.assets/image-20230416180302847.png" alt="image-20230416180302847"></p>
<h2 id="lec6-vm & replacement">lec6 vm &amp; replacement</h2>
<p>覆盖技术<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>不同时间段内执行的函数或模块共享一块有限的空间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不存在调用关系的模块可相互覆盖 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>交换技术<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>操作系统以程序为单位自动换入换出内存<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>虚拟存储<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>虚拟存储 = 内存 + 外存 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>前提是局部性原理<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p>
<p>时间局部性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>一条指令的一次执行和下次执行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一个数据的一次访问和下次访问都集中在一个较短时期内</p>
<p>空间局部性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>当前指令和邻近时间的几条指令<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>当前访问的数据和邻近时间访问的几个数据都集中在一个较小区域内</p>
<p>分支局部性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>一条跳转指令的两次执行<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>很可能跳到相同的内存位置</p>
<p><img src="os.assets/image-20230415161827584.png" alt="image-20230415161827584"></p>
<h3 id="**局部页面置换算法**"><strong>局部页面置换算法</strong></h3>
<p>置换页面的选择范围仅限于当前进程占用的物理页面内<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>每个任务分配固定大小的物理页<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不会动态调整任务拥有的物理页数量<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>只考虑单个任务的内存访问情况<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不影响其他任务拥有的物理内存<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>最优页面置换算法 (OPT, optimal)</strong> 缺页时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>计算内存中每个逻辑页面的下一次访问时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>选择未来最长时间不访问的页面</p>
<p><strong>先进先出页面置换算法 (FIFO)</strong> 维护一个记录所有位于内存中的逻辑页面链表<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>表元素按驻留内存的时间排序<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>链首最长<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>链尾最短<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>出现缺页时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>选择链首页面进行置换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>新页面加到链尾<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>分配物理页面数增加时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>缺页并不一定减少(Belady现象)</p>
<p><strong>最近最久未使用算法 (LRU, Least Recently Used)</strong>  缺页时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>计算内存中每个逻辑页面的上一次访问时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>选择上一次使用到当前时间最长的页面进行置换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>时钟页面置换算法 (Clock)</strong>  各页面组织成环形链表<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>指针指向最先调入的页面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>页面装入内存时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>访问位初始化为0  ;访问页面<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>读/写)时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>访问位置1  <span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>缺页时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从指针当前位置顺序检查 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li>访问位为0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则置换该页 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>后访问位置1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并指针移动到下一个页面 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span></li>
<li>访问位为1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则访问位置0<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并指针移动到下一个页面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直到找到可置换的页面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ul>
<p><strong>改进的时钟页面置换算法</strong>  减少修改页的缺页处理开销  <span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>访问页面时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在页表项记录页面访问情况  <span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>修改页面时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在页表项记录页面修改情况  <span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>缺页时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>修改页面标志位<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以跳过有修改的页面  <span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>标志位为两位<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>读 00 -&gt; 10<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>写 00 -&gt; 11<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>最不常用置换算法 (LFU, Least Frequently Used )</strong> 缺页时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>置换访问次数最少的页面<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>Belady 现象</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>分配的物理页面数增加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>缺页次数反而升高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>OPT 和 LRU 不会有 Belady<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不恢复计数的 LFU<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>FIFO 和 CLOCK 会有 Belady<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>例子<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>3 / 4 页帧<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>1 2 3 4 1 2 5 1 2 3 4 5<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<blockquote>
<p>期中考完 Update<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>LFU 那道判断题竟然算没有 Belady 现象<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>明明不恢复计数的会有<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>参见 Reference 的那篇 Blog<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>去查卷也没查出个所以然<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是成功面到了 rls<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也算值了 :)</p>
</blockquote>
<h3 id="全局页面置换算法">全局页面置换算法</h3>
<p><strong>工作集页面置换算法</strong> 全局页面置换算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>可动态调整某任务拥有的物理内存大小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>影响其他任务拥有的物理内存大小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="os.assets/image-20230415170030265.png" alt="image-20230415170030265"></p>
<p><strong>常驻集<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>在当前时刻<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>进程实际驻留内存中的页面集合</strong>  <span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>工作集是进程在运行过程中的固有性质<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>常驻集取决于系统分配给进程的物理页面数目和页面置换算法.常驻集包括工作集时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>缺页较少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>工作集替换算法</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>每次访存换出不在工作集中的页面  <span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>缺页率页面置换算法</strong> 缺页率<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>缺页次数 / 内存访问次数 或 缺页平均时间间隔的倒数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>通过调节常驻集大小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使每个进程的缺页率保持在一个合理的范围内  <span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="os.assets/image-20230415174756635.png" alt="image-20230415174756635"></p>
<p><strong>抖动问题</strong>  由于分配给进程的物理页面太少无法包含工作集导致大量缺页而频繁置换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从而进程运行速度变慢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>操作系统需在并发水平和缺页率之间达到一个平衡 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="lec7-& 8 scheduler">lec7 &amp; 8 scheduler</h2>
<p>一个具有一定独立功能的程序在某数据集合上的一次执行和资源使用的动态过程</p>
<p>任务和进程的区别<span class="bd-box"><h-char class="bd bd-beg"><h-inner>？</h-inner></h-char></span>进程可以在运行的过程中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>创建子进程 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span> 用新的程序内容覆盖已有的程序内容<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>进程成为程序执行过程中动态申请/使用/释放各种资源的载体</p>
<p>shell 启动过程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>OS 初始化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>找到 initproc执行程序并创建其 PCB<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后执行 initproc<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它执行 fork+exec user_shell<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>执行 waitpid 等待子进程</p>
<h3 id="单处理机调度">单处理机调度</h3>
<p>进程在CPU计算和I/O操作间交替<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>每次调度决定在下一个CPU计算时将哪个工作交给CPU <span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>吞吐量与延迟有 trade off<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h4 id="调度算法">调度算法</h4>
<p><strong>先来先服务调度算法FCFS</strong> 依据进程进入就绪状态的先后顺序排列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>指标是周转时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>为结束时间的均值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>短作业优先调度算法SJF</strong> 选择就绪队列中执行时间最短作业/进程占用CPU进入运行状态  <span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>就绪队列按预期的执行时间来排序  <span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>最短剩余时间算法SRT</strong>  有新的进程就绪<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且新进程的服务时间小于当前进程的剩余时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则转到新的进程执行 <span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>抢占式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>最高响应比优先算法HRRN</strong> 选择就绪队列中响应比R值最高的进程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>R = (就绪等待时间 / 执行时间) + 1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>时间片轮转算法RR</strong>  时间片结束时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>按FCFS算法切换到下一个就绪进程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>多级队列调度算法MQ</strong>  就绪队列被划分成多个独立的子队列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>同一优先级的进程属于某个队列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且不能跨越队列</p>
<p><strong>多级反馈队列调度算法MLFQ</strong> 工作进入系统时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>放在最高优先级<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>如进程在当前的时间片没有完成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则降到下一个优先级<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>如果工作在其时间片以内主动释放CPU<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则优先级不变<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>时间片大小随优先级级别增加而增加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>经过一段时间S<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就将系统中所有工作重新加入最高优先级队列<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h4 id="实时调度算法">实时调度算法</h4>
<p>Real-time OS: 正确性依赖于其时间和功能两方面的操作系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>实时操作系统的性能指标<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>时间约束的及时性<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>deadlines<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p>
<p><strong>静态优先级调度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>速率单调调度算法<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>Rate Monotonic<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></strong>  根据任务周期来确定任务优先级<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>周期越短优先级越高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>抢占式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>动态优先级调度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>最早截止时间优先算法<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>EDF, Earliest Deadline First<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></strong>  任务的优先级根据任务的截止时间动态分配<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>截止时间越短<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>优先级越高<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>最低松弛度优先算法<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>LLF<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></strong>  根据任务紧急或者松弛程度<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>来确定任务优先级<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>松弛度=必须完成时间-本身还需要运行时间-当前时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>优先级反置</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>高优先级进程长时间等待低优先级进程所占用资源的现象<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="os.assets/image-20230610225445360.png" alt="image-20230610225445360"></p>
<p>两种解决方案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>① <strong>优先级继承</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>占用资源的低优先级进程继承申请资源的高优先级进程的优先级<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>只在占有资源的低优先级进程被阻塞时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>才提高占有资源进程的优先级<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>② <strong>优先级天花板协议</strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>占用资源进程的优先级与所有可能申请该资源的进程的最高优先级相同<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>不管是否发生等待,都提升占用资源进程的优先级<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>优先级高于系统中所有被锁定的资源的优先级上限<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>任务执行临界区时就不会被阻塞<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h3 id="多处理机调度">多处理机调度</h3>
<p><img src="os.assets/image-20230610231901528.png" alt="image-20230610231901528"></p>
<p>SMP是指对称多处理器结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是指服务器中多个CPU对称工作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>无主次或从属关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>各CPU共享相同的物理内存<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个 CPU访问内存中的任何地址所需时间是相同的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此SMP也被称为一致存储器访问结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>NUMA 架构为非一致性存储器访问架构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>NUMA 服务器的基本特征是具有多个CPU模块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个CPU模块由多个CPU(如4个)组成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并且具有独立的本地内存<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>I/O槽口等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>MMP 也被称为海量并行处理架构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>MPP 提供了另外一种进行系统扩展的方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>它由多个SMP服务器通过一定的节点互联网络进行连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>协同工作<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>完成相同的任务<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>从用户的角度来看是一个服务器系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>单队列多处理器调度 SQMS<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>Multiprocessor Scheduling<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></strong>  缺乏可扩展性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>缓存亲和性弱<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>多队列多处理器调度 MQMS</strong>   每个 CPU 调度相互独立<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>避免单队列方式的数据共享及同步问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>但是<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可能存在负载不均衡的问题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这可以通过<strong>进程迁移</strong>或者<strong>工作窃取</strong>缓解<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>虽然很有意思但是 Linux 内的调度算法与历史演进过程的三节不考 :)</p>
<h2 id="lec9-fs">lec9 fs</h2>
<p>文件系统是存储设备上组织文件的方法和数据结构<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是管理持久性数据的子系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是操作系统中负责文件命名<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>存储和检索的子系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>文件是具有符号名<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>由字节序列构成的数据项集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>文件头<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>文件系统元数据中的文件信息<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>UNIX类操作系统的一个设计哲学<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>一切都是文件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>文件系统的存储视图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>SuperBlock, inode, dir_entry, data block<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>文件数据块的分配方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>① 连续分配<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>高效的顺序和随机读访问<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>频繁分配会带来碎片<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>增加文件内容开销大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span> ② 链式分配<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>创建<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>增大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>缩小很容易<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>几乎没有碎片<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>随机访问效率低<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可靠性差<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>分为显式链接和隐式链接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>前者显式建立常驻内存的文件分配表 FAT 记录盘块的先后关系<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>隐式则是盘块中记录下一个盘块的指针<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span> ③ 索引分配<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>创建<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>增大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>缩小很容易<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>几乎没有碎片<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>支持直接访问<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>当文件很小时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>存储索引的开销相对大<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></p>
<p>为了处理大文件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>引入链式索引 / 多级索引的索引分配方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="os.assets/image-20230610235347956.png" alt="image-20230610235347956"></p>
<p>每次读数据需要 Read Inode, Read Data, Write Inode</p>
<p><img src="os.assets/image-20230610235355124.png" alt="image-20230610235355124"></p>
<p>如果需要创建一个新的 Inode  / Data block<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则需要对对应的 bitmap 先 R 后 W<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>创建新文件需要 write 新文件的 inode<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>父目录的 inode 和父目录的 data block<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>对文件写入则需要 R Inode<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>W 数据块<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>W Inode<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>多数磁盘划分为一个或多个分区<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每个分区有一个独立的文件系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>崩溃一致性问题</strong><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>crash-consistency problem<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>也称一致性更新问题<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>consistent-update problem<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>特定操作需要更新磁盘上的两个结构A和B<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>磁盘一次只为一个请求提供服务<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因此其中一个请求将首先到达磁盘<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>A或B<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>如果在一次写入完成后系统崩溃或断电<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则磁盘上的结构将处于不一致<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>inconsistent<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>的状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>文件系统检查程序 fsck 是一种修复方案<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>允许不一致的事情发生<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后在重启时修复它们<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>目标<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>确保文件系统<strong>元数据</strong>内部一致<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>缺点是慢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>可能丢数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>数据日志</strong>的更新流程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ol>
<li>
<p>日志写入 Journal write<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>将事务的内容<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>包括TxB<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>元数据和数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>写入日志<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>等待这些写入完成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li>
<p>日志提交 Journal Commit<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>将事务提交块<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>包括TxE<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>写入日志<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>等待写完成<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>事务被认为已提交<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>committed<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li>
<p>加检查点 Checkpoint<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>将更新内容<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>元数据和数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>写入其最终的磁盘位置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
</ol>
<p>数据日志的崩溃恢复<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li>崩溃发生在Journal Commit完成前<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>文件系统可以丢掉之前写入的log<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于磁盘具体位置的bitmap<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>inodes<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>data blocks都没变<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以可以确保文件系统一致性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>崩溃发生在Journal Commit后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>Checkpoint之前<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>文件系统在启动时候<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以扫描所有已经commited的log<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>然后针对每一个log记录操作进行replay<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即recovery的过程中执行Checkpoint<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>将log的信息回写到磁盘对应的位置<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>这种操作也成为redo logging<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li>崩溃发生在Checkpoint完成后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>那无所谓<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>都已经成功回写到磁盘了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>文件系统的bitmap<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>inodes<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>data blocks也能确保一致性<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ul>
<p>日志文件系统的性能优化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>太多写<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>慢<span class="bd-box"><h-char class="bd bd-beg"><h-inner>！</h-inner></h-char></span>从记录数据+元数据日志<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>转变成只记录元数据日志<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>不同日志模式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p>Journal Mode: 操作的metadata和file data都会写入到日志中然后提交<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这是最慢的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>Ordered Mode: 只有metadata操作会写入到日志中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但是确保数据在日志提交前写入到磁盘中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>速度较快<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>Writeback Mode: 只有metadata操作会写入到日志中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>且不确保数据在日志提交前写入<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>速度最快<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="lec10-& 11 ipc 线程与协程">lec10 &amp; 11 IPC 线程与协程</h2>
<p><strong>进程间通信</strong>的定义<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>各进程之间通过<strong>数据交换</strong><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>共享或传递<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>进行<strong>交互</strong>的行为<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>分为直接通信<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>不需要 OS 中转<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>和间接通信两种方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="os.assets/image-20230610232759999.png" alt="image-20230610232759999"></p>
<img src="os.assets/image-20230610233032097.png" alt="image-20230610233032097" style="zoom: 67%;" />
<p>进程是资源<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>包括内存<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>打开的文件等<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>分配的单位<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>线程是 CPU 调度的单位<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>线程是进程的一部分<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>描述指令流执行状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>线程 = 进程 - 共享资源<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>线程的<strong>设计实现</strong>有以下方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li>用户态管理且用户态运行的线程<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>内核不可见的用户线程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
<li>内核态管理且用户态运行的线程</li>
<li>内核态管理且内核态运行的线程</li>
<li>双态管理的线程<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>轻量级进程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>LWP<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
</ul>
<p><img src="os.assets/image-20230610002430447.png" alt="image-20230610002430447"></p>
<p>相同进程中的线程切换<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>虚拟内存是共享的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>切换时虚拟内存这些资源就保持不动<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>只需要切换线程的私有数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>寄存器等不共享的数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>协程</strong>的核心思想<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>控制流的主动让出与恢复<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>无栈协程是普通函数的泛化<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>优点<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>协程创建成本小<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>降低了内存消耗<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>协程自己的调度器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>减少了 CPU 上下文切换的开销<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>提高了 CPU 缓存命中率<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>减少同步加锁<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>整体上提高了性能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>可按照同步思维写异步代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>协程适合<strong>IO密集型</strong>场景<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>依照三个因素来对协程进行分类<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li>控制<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>控制权<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>传递机制<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>对称协程<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>等价<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span> / 非对称协程<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>调用与挂起<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
<li>栈式构造<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>有栈协程 / 无栈协程</li>
<li>编程语言中第一类<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>First-class<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>对象<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>First-class对象 / second-class对象</li>
</ul>
<p>需要切换的内容<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>进程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>页表<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>堆<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>栈<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>寄存器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>线程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>栈<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>寄存器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>协程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>寄存器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="lec12-同步互斥">lec12 同步互斥</h2>
<p>临界区(Critical Section) – 访问规则</p>
<ul>
<li>空闲则入<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>没有线程在临界区时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>任何线程可进入</li>
<li>忙则等待<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>有线程在临界区时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其他线程均不能进入临界区</li>
<li>有限等待<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>等待进入临界区的线程不能无限期等待</li>
<li>让权等待<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>可选<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>不能进入临界区的线程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>应释放CPU<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>如转换到阻塞状态<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
</ul>
<p>同步互斥的方法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li>方法1<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>禁用硬件中断<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>进入临界区<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>禁止所有中断<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并保存标志<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>离开临界区<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>使能所有中断<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并恢复标志<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
<li>方法2<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>基于软件的解决方法</li>
</ul>
<p><img src="os.assets/image-20230610011611010.png" alt="image-20230610011611010"></p>
<p><img src="os.assets/image-20230610011703112.png" alt="image-20230610011703112"></p>
<p><img src="os.assets/image-20230610011741228.png" alt="image-20230610011741228"></p>
<p><img src="os.assets/image-20230610011811568.png" alt="image-20230610011811568"></p>
<ul>
<li>方法3<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>更高级的抽象方法<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>锁<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使用 TestAndSet / CaS<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>自旋锁或忙等锁 v.s. 等待锁<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
</ul>
<p>信号量<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>互斥访问 和 条件同步<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>P 尝试减少<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果 &lt; 0 进入等待<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>否则继续<span class="bd-box"><h-char class="bd bd-beg"><h-inner>；</h-inner></h-char></span>V 是增加<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如果 &lt;= 0 唤醒一个等待的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>管程<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>一个管程是一个基本程序单位<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是一种特殊的数据类型<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中不仅有数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>而且有对数据进行操作的代码<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="https://git.net9.org/cc7w/picgo/uploads/356bd91a2d2386a5f0647a633aa177c1/image-20230610144923717.png" alt="image-20230610144923717"></p>
<p><img src="os.assets/image-20230610144940770.png" alt="image-20230610144940770"></p>
<p><img src="os.assets/image-20230610150342525.png" alt="image-20230610150342525"></p>
<p><img src="os.assets/image-20230610150917980.png" alt="image-20230610150917980"></p>
<p><img src="os.assets/image-20230610151726858.png" alt="image-20230610151726858"></p>
<p><img src="os.assets/image-20230610152021692.png" alt="image-20230610152021692"></p>
<p><span class="bd-box"><h-char class="bd bd-end"><h-inner>【</h-inner></h-char></span>读者写者问题的信号量实现<span class="bd-box"><h-char class="bd bd-beg"><h-inner>】</h-inner></h-char></span></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Readers%E2%80%93writers_problem#cite_note-3">https://en.wikipedia.org/wiki/Readers–writers_problem#cite_note-3</a></p>
<p><strong>读者优先</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">semaphore resource=<span class="number">1</span>;</span><br><span class="line">semaphore rmutex=<span class="number">1</span>;</span><br><span class="line">readcount=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   resource.P() is equivalent to wait(resource)</span></span><br><span class="line"><span class="comment">   resource.V() is equivalent to signal(resource)</span></span><br><span class="line"><span class="comment">   rmutex.P() is equivalent to wait(rmutex)</span></span><br><span class="line"><span class="comment">   rmutex.V() is equivalent to signal(rmutex)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">writer() &#123;</span><br><span class="line">    resource.P();          <span class="comment">//Lock the shared file for a writer</span></span><br><span class="line"></span><br><span class="line">    &lt;CRITICAL Section&gt;</span><br><span class="line">    <span class="comment">// Writing is done</span></span><br><span class="line"></span><br><span class="line">    &lt;EXIT Section&gt;</span><br><span class="line">    resource.V();          <span class="comment">//Release the shared file for use by other readers. Writers are allowed if there are no readers requesting it.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader() &#123;</span><br><span class="line">    rmutex.P();           <span class="comment">//Ensure that no other reader can execute the &lt;Entry&gt; section while you are in it</span></span><br><span class="line">    &lt;CRITICAL Section&gt;</span><br><span class="line">    readcount++;          <span class="comment">//Indicate that you are a reader trying to enter the Critical Section</span></span><br><span class="line">    <span class="keyword">if</span> (readcount == <span class="number">1</span>)   <span class="comment">//Checks if you are the first reader trying to enter CS</span></span><br><span class="line">        resource.P();     <span class="comment">//If you are the first reader, lock the resource from writers. Resource stays reserved for subsequent readers</span></span><br><span class="line">    &lt;EXIT CRITICAL Section&gt;</span><br><span class="line">    rmutex.V();           <span class="comment">//Release</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do the Reading</span></span><br><span class="line"></span><br><span class="line">    rmutex.P();           <span class="comment">//Ensure that no other reader can execute the &lt;Exit&gt; section while you are in it</span></span><br><span class="line">    &lt;CRITICAL Section&gt;</span><br><span class="line">    readcount--;          <span class="comment">//Indicate that you no longer need the shared resource. One fewer reader</span></span><br><span class="line">    <span class="keyword">if</span> (readcount == <span class="number">0</span>)   <span class="comment">//Checks if you are the last (only) reader who is reading the shared file</span></span><br><span class="line">        resource.V();     <span class="comment">//If you are last reader, then you can unlock the resource. This makes it available to writers.</span></span><br><span class="line">    &lt;EXIT CRITICAL Section&gt;</span><br><span class="line">    rmutex.V();           <span class="comment">//Release</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>写者优先</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> readcount, writecount;                   <span class="comment">//(initial value = 0)</span></span><br><span class="line">semaphore rmutex, wmutex, readTry, resource; <span class="comment">//(initial value = 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//READER</span></span><br><span class="line">reader() &#123;</span><br><span class="line">&lt;ENTRY Section&gt;</span><br><span class="line">  readTry.P();                 <span class="comment">//Indicate a reader is trying to enter</span></span><br><span class="line">  rmutex.P();                  <span class="comment">//lock entry section to avoid race condition with other readers</span></span><br><span class="line">  readcount++;                 <span class="comment">//report yourself as a reader</span></span><br><span class="line">  <span class="keyword">if</span> (readcount == <span class="number">1</span>)          <span class="comment">//checks if you are first reader</span></span><br><span class="line">    resource.P();              <span class="comment">//if you are first reader, lock the resource</span></span><br><span class="line">  rmutex.V();                  <span class="comment">//release entry section for other readers</span></span><br><span class="line">  readTry.V();                 <span class="comment">//indicate you are done trying to access the resource</span></span><br><span class="line"></span><br><span class="line">&lt;CRITICAL Section&gt;</span><br><span class="line"><span class="comment">//reading is performed</span></span><br><span class="line"></span><br><span class="line">&lt;EXIT Section&gt;</span><br><span class="line">  rmutex.P();                  <span class="comment">//reserve exit section - avoids race condition with readers</span></span><br><span class="line">  readcount--;                 <span class="comment">//indicate you&#x27;re leaving</span></span><br><span class="line">  <span class="keyword">if</span> (readcount == <span class="number">0</span>)          <span class="comment">//checks if you are last reader leaving</span></span><br><span class="line">    resource.V();              <span class="comment">//if last, you must release the locked resource</span></span><br><span class="line">  rmutex.V();                  <span class="comment">//release exit section for other readers</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//WRITER</span></span><br><span class="line">writer() &#123;</span><br><span class="line">&lt;ENTRY Section&gt;</span><br><span class="line">  wmutex.P();                  <span class="comment">//reserve entry section for writers - avoids race conditions</span></span><br><span class="line">  writecount++;                <span class="comment">//report yourself as a writer entering</span></span><br><span class="line">  <span class="keyword">if</span> (writecount == <span class="number">1</span>)         <span class="comment">//checks if you&#x27;re first writer</span></span><br><span class="line">    readTry.P();               <span class="comment">//if you&#x27;re first, then you must lock the readers out. Prevent them from trying to enter CS</span></span><br><span class="line">  wmutex.V();                  <span class="comment">//release entry section</span></span><br><span class="line">  resource.P();                <span class="comment">//reserve the resource for yourself - prevents other writers from simultaneously editing the shared resource</span></span><br><span class="line">&lt;CRITICAL Section&gt;</span><br><span class="line">  <span class="comment">//writing is performed</span></span><br><span class="line">  resource.V();                <span class="comment">//release file</span></span><br><span class="line"></span><br><span class="line">&lt;EXIT Section&gt;</span><br><span class="line">  wmutex.P();                  <span class="comment">//reserve exit section</span></span><br><span class="line">  writecount--;                <span class="comment">//indicate you&#x27;re leaving</span></span><br><span class="line">  <span class="keyword">if</span> (writecount == <span class="number">0</span>)         <span class="comment">//checks if you&#x27;re the last writer</span></span><br><span class="line">    readTry.V();               <span class="comment">//if you&#x27;re last writer, you must unlock the readers. Allows them to try enter CS for reading</span></span><br><span class="line">  wmutex.V();                  <span class="comment">//release exit section</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>保证公平防止饥饿</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> readcount;                <span class="comment">// init to 0; number of readers currently accessing resource</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// all semaphores initialised to 1</span></span><br><span class="line">semaphore resource;           <span class="comment">// controls access (read/write) to the resource. Binary semaphore.</span></span><br><span class="line">semaphore rmutex;             <span class="comment">// for syncing changes to shared variable readcount</span></span><br><span class="line">semaphore serviceQueue;       <span class="comment">// FAIRNESS: preserves ordering of requests (signaling must be FIFO)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//READER</span></span><br><span class="line">reader() &#123;</span><br><span class="line">&lt;ENTRY Section&gt;</span><br><span class="line">  serviceQueue.P();           <span class="comment">// wait in line to be serviced</span></span><br><span class="line">  rmutex.P();                 <span class="comment">// request exclusive access to readcount</span></span><br><span class="line">  readcount++;                <span class="comment">// update count of active readers</span></span><br><span class="line">  <span class="keyword">if</span> (readcount == <span class="number">1</span>)         <span class="comment">// if I am the first reader</span></span><br><span class="line">    resource.P();             <span class="comment">// request resource access for readers (writers blocked)</span></span><br><span class="line">  serviceQueue.V();           <span class="comment">// let next in line be serviced</span></span><br><span class="line">  rmutex.V();                 <span class="comment">// release access to readcount</span></span><br><span class="line">    </span><br><span class="line">&lt;CRITICAL Section&gt;</span><br><span class="line"><span class="comment">//reading is performed</span></span><br><span class="line">    </span><br><span class="line">&lt;EXIT Section&gt;</span><br><span class="line">  rmutex.P();                 <span class="comment">// request exclusive access to readcount</span></span><br><span class="line">  readcount--;                <span class="comment">// update count of active readers</span></span><br><span class="line">  <span class="keyword">if</span> (readcount == <span class="number">0</span>)         <span class="comment">// if there are no readers left</span></span><br><span class="line">    resource.V();             <span class="comment">// release resource access for all</span></span><br><span class="line">  rmutex.V();                 <span class="comment">// release access to readcount</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//WRITER</span></span><br><span class="line">writer() &#123;</span><br><span class="line">&lt;ENTRY Section&gt;</span><br><span class="line">  serviceQueue.P();           <span class="comment">// wait in line to be serviced</span></span><br><span class="line">  resource.P();               <span class="comment">// request exclusive access to resource</span></span><br><span class="line">  serviceQueue.V();           <span class="comment">// let next in line be serviced</span></span><br><span class="line">    </span><br><span class="line">&lt;CRITICAL Section&gt;</span><br><span class="line"><span class="comment">// writing is performed</span></span><br><span class="line">    </span><br><span class="line">&lt;EXIT Section&gt;</span><br><span class="line">  resource.V();               <span class="comment">// release resource access for next reader/writer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="os.assets/image-20230610152658257.png" alt="image-20230610152658257"></p>
<p><img src="os.assets/image-20230610152706036.png" alt="image-20230610152706036"></p>
<p>死锁问题 – 必要条件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<ul>
<li>互斥<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>任何时刻只能有一个进/线程使用一个资源实例</li>
<li>持有并等待<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>进/线程保持至少一个资源<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>并正在等待获取其他进程持有的资源</li>
<li>非抢占<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>资源只能在进程使用后自愿释放</li>
<li>循环等待<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>存在等待进程集合<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>进程间形成相互等待资源的环</li>
</ul>
<p>死锁问题的避免<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span>银行家算法</p>
<p><img src="os.assets/image-20230610155503719.png" alt="image-20230610155503719"></p>
<p><img src="os.assets/image-20230610155604440.png" alt="image-20230610155604440"></p>
<p><img src="os.assets/image-20230610155826240.png" alt="image-20230610155826240"></p>
<p>除了死锁避免算法之外<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>我们还可以利用死锁检测与恢复<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>允许出现死锁<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span>的算法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>死锁检测算法与上面判断安全状态的例程相似<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但注意将 Allocation==0 的线程的 finish 直接设置为 true<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>恢复包括进程终止和资源抢占两种方式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="reference">Reference</h2>
<ul>
<li>2023S <span class="bd-box"><h-char class="bd bd-end"><h-inner>《</h-inner></h-char></span>操作系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>》</h-inner></h-char></span>课程 Slides</li>
<li><a target="_blank" rel="noopener" href="https://learningos.github.io/rCore-Tutorial-Guide-2023S/index.html">https://learningos.github.io/rCore-Tutorial-Guide-2023S/index.html</a></li>
<li><a target="_blank" rel="noopener" href="https://twinkle0331.github.io/categories/Systems/">https://twinkle0331.github.io/categories/Systems/</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="../hello-world/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Hello World
        
      </div>
    </a>
  
  
    <a href="../license/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">
        
          常见开源协议简介
        
      </div>
    </a>
  
</nav>

  
</article>


</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
        <div><p><span id="busuanzi_container_site_pv">Site total view count: <span id="busuanzi_value_site_pv">Loading...</span></span></p><p>Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">Hexo</a> & Theme <a target="_blank" rel="noopener" href="https://github.com/bill-xia/hexo-theme-mashiro">Mashiro</a> & GitHub Pages</p><p>Copyright © 2020-2024 c7w. LICENSE CC BY-NC-SA 4.0.</p></div>
      
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="../../index.html" class="mobile-nav-link">Home</a>
  
    <a href="../../archives" class="mobile-nav-link">Posts</a>
  
    <a href="../../about" class="mobile-nav-link">About</a>
  
    <a href="../../friends" class="mobile-nav-link">Friends</a>
  
</nav>
    
<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="../../js/clipboard.min.js"></script>
<script src="../../js/jquery-1.4.3.min.js"></script>

<script src="../../fancybox/jquery.fancybox-1.3.4.pack.js"></script>


<script src="../../js/script.js"></script>








<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" integrity="sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" integrity="sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        {left: '$$', right: '$$', display: true},
        {left: '$', right: '$', display: false},
        {left: '\\(', right: '\\)', display: false},
        {left: '\\[', right: '\\]', display: true}
      ],
      throwOnError : false
    });
  });
</script>

  </div>
</body>
</html>